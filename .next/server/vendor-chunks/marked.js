"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/marked";
exports.ids = ["vendor-chunks/marked"];
exports.modules = {

/***/ "(ssr)/./node_modules/marked/lib/marked.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/marked/lib/marked.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hooks: () => (/* binding */ _Hooks),\n/* harmony export */   Lexer: () => (/* binding */ _Lexer),\n/* harmony export */   Marked: () => (/* binding */ Marked),\n/* harmony export */   Parser: () => (/* binding */ _Parser),\n/* harmony export */   Renderer: () => (/* binding */ _Renderer),\n/* harmony export */   TextRenderer: () => (/* binding */ _TextRenderer),\n/* harmony export */   Tokenizer: () => (/* binding */ _Tokenizer),\n/* harmony export */   defaults: () => (/* binding */ _defaults),\n/* harmony export */   getDefaults: () => (/* binding */ _getDefaults),\n/* harmony export */   lexer: () => (/* binding */ lexer),\n/* harmony export */   marked: () => (/* binding */ marked),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseInline: () => (/* binding */ parseInline),\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   setOptions: () => (/* binding */ setOptions),\n/* harmony export */   use: () => (/* binding */ use),\n/* harmony export */   walkTokens: () => (/* binding */ walkTokens)\n/* harmony export */ });\n/**\n * marked v11.2.0 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ /**\n * Gets the original marked default options.\n */ function _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null\n    };\n}\nlet _defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n/**\n * Helpers\n */ const escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, \"g\");\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, \"g\");\nconst escapeReplacements = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nconst getEscapeReplacement = (ch)=>escapeReplacements[ch];\nfunction escape$1(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\nfunction unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, (_, n)=>{\n        n = n.toLowerCase();\n        if (n === \"colon\") return \":\";\n        if (n.charAt(0) === \"#\") {\n            return n.charAt(1) === \"x\" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n        }\n        return \"\";\n    });\n}\nconst caret = /(^|[^\\[])\\^/g;\nfunction edit(regex, opt) {\n    let source = typeof regex === \"string\" ? regex : regex.source;\n    opt = opt || \"\";\n    const obj = {\n        replace: (name, val)=>{\n            let valSource = typeof val === \"string\" ? val : val.source;\n            valSource = valSource.replace(caret, \"$1\");\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: ()=>{\n            return new RegExp(source, opt);\n        }\n    };\n    return obj;\n}\nfunction cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(/%25/g, \"%\");\n    } catch (e) {\n        return null;\n    }\n    return href;\n}\nconst noopTest = {\n    exec: ()=>null\n};\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str)=>{\n        let escaped = false;\n        let curr = offset;\n        while(--curr >= 0 && str[curr] === \"\\\\\")escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n        } else {\n            // add space before unescaped |\n            return \" |\";\n        }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        } else {\n            while(cells.length < count)cells.push(\"\");\n        }\n    }\n    for(; i < cells.length; i++){\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, \"|\");\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */ function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return \"\";\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while(suffLen < l){\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        } else if (currChar !== c && invert) {\n            suffLen++;\n        } else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for(let i = 0; i < str.length; i++){\n        if (str[i] === \"\\\\\") {\n            i++;\n        } else if (str[i] === b[0]) {\n            level++;\n        } else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nfunction outputLink(cap, link, raw, lexer) {\n    const href = link.href;\n    const title = link.title ? escape$1(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, \"$1\");\n    if (cap[0].charAt(0) !== \"!\") {\n        lexer.state.inLink = true;\n        const token = {\n            type: \"link\",\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: \"image\",\n        raw,\n        href,\n        title,\n        text: escape$1(text)\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text.split(\"\\n\").map((node)=>{\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    }).join(\"\\n\");\n}\n/**\n * Tokenizer\n */ class _Tokenizer {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ {1,4}/gm, \"\");\n            return {\n                type: \"code\",\n                raw: cap[0],\n                codeBlockStyle: \"indented\",\n                text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || \"\");\n            return {\n                type: \"code\",\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, \"$1\") : cap[2],\n                text\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, \"#\");\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: \"hr\",\n                raw: cap[0]\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            const text = rtrim(cap[0].replace(/^ *>[ \\t]?/gm, \"\"), \"\\n\");\n            const top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            const tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n                type: \"blockquote\",\n                raw: cap[0],\n                tokens,\n                text\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: \"list\",\n                raw: \"\",\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : \"\",\n                loose: false,\n                items: []\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : \"[*+-]\";\n            }\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let raw = \"\";\n            let itemContents = \"\";\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while(src){\n                let endEarly = false;\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) {\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split(\"\\n\", 1)[0].replace(/^\\t+/, (t)=>\" \".repeat(3 * t.length));\n                let nextLine = src.split(\"\\n\", 1)[0];\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                } else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                let blankLine = false;\n                if (!line && /^ *$/.test(nextLine)) {\n                    raw += nextLine + \"\\n\";\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                    // Check if following lines should be included in List Item\n                    while(src){\n                        const rawLine = src.split(\"\\n\", 1)[0];\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, \"  \");\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {\n                            itemContents += \"\\n\" + nextLine.slice(indent);\n                        } else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) {\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += \"\\n\" + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) {\n                            blankLine = true;\n                        }\n                        raw += rawLine + \"\\n\";\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    } else if (/\\n *\\n *$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== \"[ ] \";\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, \"\");\n                    }\n                }\n                list.items.push({\n                    type: \"list_item\",\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: []\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = raw.trimEnd();\n            list.items[list.items.length - 1].text = itemContents.trimEnd();\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for(let i = 0; i < list.items.length; i++){\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter((t)=>t.type === \"space\");\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>/\\n.*\\n/.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for(let i = 0; i < list.items.length; i++){\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: \"html\",\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\",\n                text: cap[0]\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, \" \");\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, \"$1\").replace(this.rules.inline.anyPunctuation, \"$1\") : \"\";\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, \"$1\") : cap[3];\n            return {\n                type: \"def\",\n                tag,\n                raw: cap[0],\n                href,\n                title\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!/[:|]/.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(/^\\||\\| *$/g, \"\").split(\"|\");\n        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, \"\").split(\"\\n\") : [];\n        const item = {\n            type: \"table\",\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: []\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns){\n            if (/^ *-+: *$/.test(align)) {\n                item.align.push(\"right\");\n            } else if (/^ *:-+: *$/.test(align)) {\n                item.align.push(\"center\");\n            } else if (/^ *:-+ *$/.test(align)) {\n                item.align.push(\"left\");\n            } else {\n                item.align.push(null);\n            }\n        }\n        for (const header of headers){\n            item.header.push({\n                text: header,\n                tokens: this.lexer.inline(header)\n            });\n        }\n        for (const row of rows){\n            item.rows.push(splitCells(row, item.header.length).map((cell)=>{\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell)\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n            return {\n                type: \"paragraph\",\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: \"escape\",\n                raw: cap[0],\n                text: escape$1(cap[1])\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: \"html\",\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0]\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!/>$/.test(trimmedUrl)) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], \"()\");\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = \"\";\n                }\n            }\n            let href = cap[2];\n            let title = \"\";\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : \"\";\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, \"$1\") : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, \"$1\") : title\n            }, cap[0], this.lexer);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(/\\s+/g, \" \");\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: \"text\",\n                    raw: text,\n                    text\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = \"\") {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match) return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n        const nextChar = match[1] || match[2] || \"\";\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [\n                ...match[0]\n            ].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while((match = endReg.exec(maskedSrc)) != null){\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim) continue; // skip single * in __abc*abc__\n                rLength = [\n                    ...rDelim\n                ].length;\n                if (match[3] || match[4]) {\n                    delimTotal += rLength;\n                    continue;\n                } else if (match[5] || match[6]) {\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [\n                    ...match[0]\n                ][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: \"em\",\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: \"strong\",\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, \" \");\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape$1(text, true);\n            return {\n                type: \"codespan\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = escape$1(cap[1]);\n                href = \"mailto:\" + text;\n            } else {\n                text = escape$1(cap[1]);\n                href = text;\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = escape$1(cap[0]);\n                href = \"mailto:\" + text;\n            } else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? \"\";\n                }while (prevCapZero !== cap[0]);\n                text = escape$1(cap[0]);\n                if (cap[1] === \"www.\") {\n                    href = \"http://\" + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = cap[0];\n            } else {\n                text = escape$1(cap[0]);\n            }\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n}\n/**\n * Block-Level Grammar\n */ const newline = /^(?: *(?:\\n|$))+/;\nconst blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheading = edit(/^(?!bull )((?:.|\\n(?!\\s*?\\n|bull ))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/).replace(/bull/g, bullet) // lists can interrupt\n.getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/).replace(\"label\", _blockLabel).replace(\"title\", /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, bullet).getRegex();\nconst _tag = \"address|article|aside|base|basefont|blockquote|body|caption\" + \"|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption\" + \"|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe\" + \"|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option\" + \"|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr\" + \"|track|ul\";\nconst _comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nconst html = edit(\"^ {0,3}(?:\" // optional indentation\n + \"<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)\" // (1)\n + \"|comment[^\\\\n]*(\\\\n+|$)\" // (2)\n + \"|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)\" // (3)\n + \"|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)\" // (4)\n + \"|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)\" // (5)\n + \"|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (6)\n + \"|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) open tag\n + \"|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) closing tag\n + \")\", \"i\").replace(\"comment\", _comment).replace(\"tag\", _tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\nconst paragraph = edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace(\"paragraph\", paragraph).getRegex();\n/**\n * Normal Block Grammar\n */ const blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText\n};\n/**\n * GFM Block Grammar\n */ const gfmTable = edit(\"^ *([^\\\\n ].*)\\\\n\" // Header\n + \" {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)\" // Align\n + \"(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\") // Cells\n.replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \" {4}[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // tables can be interrupted by type (6) html blocks\n.getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    table: gfmTable,\n    paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n    .replace(\"table\", gfmTable) // interrupt paragraphs with table\n    .replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n    .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex()\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */ const blockPedantic = {\n    ...blockNormal,\n    html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)\" + \"|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)\" // closed tag\n     + \"|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", _comment).replace(/tag/g, \"(?!(?:\" + \"a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub\" + \"|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\" + \"\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", lheading).replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").replace(\"|tag\", \"\").getRegex()\n};\n/**\n * Inline-Level Grammar\n */ const escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = \"\\\\p{P}$+<=>`^|~\";\nconst punctuation = edit(/^((?![*_])[\\spunctuation])/, \"u\").replace(/punctuation/g, _punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, \"u\").replace(/punct/g, _punctuation).getRegex();\nconst emStrongRDelimAst = edit(\"^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)\" // Skip orphan inside strong\n + \"|[^*]+(?=[^*])\" // Consume to delim\n + \"|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)\" // (1) #*** can only be a Right Delimiter\n + \"|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)\" // (2) a***#, a*** can only be a Right Delimiter\n + \"|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])\" // (3) #***a, ***a can only be Left Delimiter\n + \"|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])\" // (4) ***# can only be Left Delimiter\n + \"|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])\" // (5) #***# can be either Left or Right Delimiter\n + \"|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])\", \"gu\") // (6) a***a can be either Left or Right Delimiter\n.replace(/punct/g, _punctuation).getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit(\"^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)\" // Skip orphan inside strong\n + \"|[^_]+(?=[^_])\" // Consume to delim\n + \"|(?!_)[punct](_+)(?=[\\\\s]|$)\" // (1) #___ can only be a Right Delimiter\n + \"|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)\" // (2) a___#, a___ can only be a Right Delimiter\n + \"|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])\" // (3) #___a, ___a can only be Left Delimiter\n + \"|[\\\\s](_+)(?!_)(?=[punct])\" // (4) ___# can only be Left Delimiter\n + \"|(?!_)[punct](_+)(?!_)(?=[punct])\", \"gu\") // (5) #___# can be either Left or Right Delimiter\n.replace(/punct/g, _punctuation).getRegex();\nconst anyPunctuation = edit(/\\\\([punct])/, \"gu\").replace(/punct/g, _punctuation).getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace(\"scheme\", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace(\"email\", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();\nconst _inlineComment = edit(_comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\nconst tag = edit(\"^comment\" + \"|^</[a-zA-Z][\\\\w:-]*\\\\s*>\" // self-closing tag\n + \"|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>\" // open tag\n + \"|^<\\\\?[\\\\s\\\\S]*?\\\\?>\" // processing instruction, e.g. <?php ?>\n + \"|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>\" // declaration, e.g. <!DOCTYPE html>\n + \"|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\") // CDATA section\n.replace(\"comment\", _inlineComment).replace(\"attribute\", /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/).replace(\"label\", _inlineLabel).replace(\"href\", /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/).replace(\"title\", /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/).replace(\"label\", _inlineLabel).replace(\"ref\", _blockLabel).getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/).replace(\"ref\", _blockLabel).getRegex();\nconst reflinkSearch = edit(\"reflink|nolink(?!\\\\()\", \"g\").replace(\"reflink\", reflink).replace(\"nolink\", nolink).getRegex();\n/**\n * Normal Inline Grammar\n */ const inlineNormal = {\n    _backpedal: noopTest,\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest\n};\n/**\n * Pedantic Inline Grammar\n */ const inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", _inlineLabel).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", _inlineLabel).getRegex()\n};\n/**\n * GFM Inline Grammar\n */ const inlineGfm = {\n    ...inlineNormal,\n    escape: edit(escape).replace(\"])\", \"~|])\").getRegex(),\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, \"i\").replace(\"email\", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */ const inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace(\"{2,}\", \"*\").getRegex(),\n    text: edit(inlineGfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n};\n/**\n * exports\n */ const block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic\n};\nconst inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic\n};\n/**\n * Block Lexer\n */ class _Lexer {\n    constructor(options){\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        const rules = {\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            } else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */ static get rules() {\n        return {\n            block,\n            inline\n        };\n    }\n    /**\n     * Static Lex Method\n     */ static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */ static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */ lex(src) {\n        src = src.replace(/\\r\\n|\\r/g, \"\\n\");\n        this.blockTokens(src, this.tokens);\n        for(let i = 0; i < this.inlineQueue.length; i++){\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = []) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, \"    \").replace(/^ +$/gm, \"\");\n        } else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs)=>{\n                return leading + \"    \".repeat(tabs.length);\n            });\n        }\n        let token;\n        let lastToken;\n        let cutSrc;\n        let lastParagraphClipped;\n        while(src){\n            if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += \"\\n\";\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken.type === \"paragraph\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({\n            src,\n            tokens\n        });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */ inlineTokens(src, tokens = []) {\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null){\n                    if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while(src){\n            if (!keepPrevChar) {\n                prevChar = \"\";\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== \"_\") {\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n/**\n * Renderer\n */ class _Renderer {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    code(code, infostring, escaped) {\n        const lang = (infostring || \"\").match(/^\\S*/)?.[0];\n        code = code.replace(/\\n$/, \"\") + \"\\n\";\n        if (!lang) {\n            return \"<pre><code>\" + (escaped ? code : escape$1(code, true)) + \"</code></pre>\\n\";\n        }\n        return '<pre><code class=\"language-' + escape$1(lang) + '\">' + (escaped ? code : escape$1(code, true)) + \"</code></pre>\\n\";\n    }\n    blockquote(quote) {\n        return `<blockquote>\\n${quote}</blockquote>\\n`;\n    }\n    html(html, block) {\n        return html;\n    }\n    heading(text, level, raw) {\n        // ignore IDs\n        return `<h${level}>${text}</h${level}>\\n`;\n    }\n    hr() {\n        return \"<hr>\\n\";\n    }\n    list(body, ordered, start) {\n        const type = ordered ? \"ol\" : \"ul\";\n        const startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n        return \"<\" + type + startatt + \">\\n\" + body + \"</\" + type + \">\\n\";\n    }\n    listitem(text, task, checked) {\n        return `<li>${text}</li>\\n`;\n    }\n    checkbox(checked) {\n        return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph(text) {\n        return `<p>${text}</p>\\n`;\n    }\n    table(header, body) {\n        if (body) body = `<tbody>${body}</tbody>`;\n        return \"<table>\\n\" + \"<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n    }\n    tablerow(content) {\n        return `<tr>\\n${content}</tr>\\n`;\n    }\n    tablecell(content, flags) {\n        const type = flags.header ? \"th\" : \"td\";\n        const tag = flags.align ? `<${type} align=\"${flags.align}\">` : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */ strong(text) {\n        return `<strong>${text}</strong>`;\n    }\n    em(text) {\n        return `<em>${text}</em>`;\n    }\n    codespan(text) {\n        return `<code>${text}</code>`;\n    }\n    br() {\n        return \"<br>\";\n    }\n    del(text) {\n        return `<del>${text}</del>`;\n    }\n    link(href, title, text) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += \">\" + text + \"</a>\";\n        return out;\n    }\n    image(href, title, text) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += \">\";\n        return out;\n    }\n    text(text) {\n        return text;\n    }\n}\n/**\n * TextRenderer\n * returns only the textual part of the token\n */ class _TextRenderer {\n    // no need for block level renderers\n    strong(text) {\n        return text;\n    }\n    em(text) {\n        return text;\n    }\n    codespan(text) {\n        return text;\n    }\n    del(text) {\n        return text;\n    }\n    html(text) {\n        return text;\n    }\n    text(text) {\n        return text;\n    }\n    link(href, title, text) {\n        return \"\" + text;\n    }\n    image(href, title, text) {\n        return \"\" + text;\n    }\n    br() {\n        return \"\";\n    }\n}\n/**\n * Parsing & Compiling\n */ class _Parser {\n    constructor(options){\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */ static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */ static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */ parse(tokens, top = true) {\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const genericToken = token;\n                const ret = this.options.extensions.renderers[genericToken.type].call({\n                    parser: this\n                }, genericToken);\n                if (ret !== false || ![\n                    \"space\",\n                    \"hr\",\n                    \"heading\",\n                    \"code\",\n                    \"table\",\n                    \"blockquote\",\n                    \"list\",\n                    \"html\",\n                    \"paragraph\",\n                    \"text\"\n                ].includes(genericToken.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"space\":\n                    {\n                        continue;\n                    }\n                case \"hr\":\n                    {\n                        out += this.renderer.hr();\n                        continue;\n                    }\n                case \"heading\":\n                    {\n                        const headingToken = token;\n                        out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));\n                        continue;\n                    }\n                case \"code\":\n                    {\n                        const codeToken = token;\n                        out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);\n                        continue;\n                    }\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        let header = \"\";\n                        // header\n                        let cell = \"\";\n                        for(let j = 0; j < tableToken.header.length; j++){\n                            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), {\n                                header: true,\n                                align: tableToken.align[j]\n                            });\n                        }\n                        header += this.renderer.tablerow(cell);\n                        let body = \"\";\n                        for(let j = 0; j < tableToken.rows.length; j++){\n                            const row = tableToken.rows[j];\n                            cell = \"\";\n                            for(let k = 0; k < row.length; k++){\n                                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                                    header: false,\n                                    align: tableToken.align[k]\n                                });\n                            }\n                            body += this.renderer.tablerow(cell);\n                        }\n                        out += this.renderer.table(header, body);\n                        continue;\n                    }\n                case \"blockquote\":\n                    {\n                        const blockquoteToken = token;\n                        const body = this.parse(blockquoteToken.tokens);\n                        out += this.renderer.blockquote(body);\n                        continue;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        const ordered = listToken.ordered;\n                        const start = listToken.start;\n                        const loose = listToken.loose;\n                        let body = \"\";\n                        for(let j = 0; j < listToken.items.length; j++){\n                            const item = listToken.items[j];\n                            const checked = item.checked;\n                            const task = item.task;\n                            let itemBody = \"\";\n                            if (item.task) {\n                                const checkbox = this.renderer.checkbox(!!checked);\n                                if (loose) {\n                                    if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                                        item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                                            item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                                        }\n                                    } else {\n                                        item.tokens.unshift({\n                                            type: \"text\",\n                                            text: checkbox + \" \"\n                                        });\n                                    }\n                                } else {\n                                    itemBody += checkbox + \" \";\n                                }\n                            }\n                            itemBody += this.parse(item.tokens, loose);\n                            body += this.renderer.listitem(itemBody, task, !!checked);\n                        }\n                        out += this.renderer.list(body, ordered, start);\n                        continue;\n                    }\n                case \"html\":\n                    {\n                        const htmlToken = token;\n                        out += this.renderer.html(htmlToken.text, htmlToken.block);\n                        continue;\n                    }\n                case \"paragraph\":\n                    {\n                        const paragraphToken = token;\n                        out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                        continue;\n                    }\n                case \"text\":\n                    {\n                        let textToken = token;\n                        let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                        while(i + 1 < tokens.length && tokens[i + 1].type === \"text\"){\n                            textToken = tokens[++i];\n                            body += \"\\n\" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                        }\n                        out += top ? this.renderer.paragraph(body) : body;\n                        continue;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */ parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const ret = this.options.extensions.renderers[token.type].call({\n                    parser: this\n                }, token);\n                if (ret !== false || ![\n                    \"escape\",\n                    \"html\",\n                    \"link\",\n                    \"image\",\n                    \"strong\",\n                    \"em\",\n                    \"codespan\",\n                    \"br\",\n                    \"del\",\n                    \"text\"\n                ].includes(token.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"escape\":\n                    {\n                        const escapeToken = token;\n                        out += renderer.text(escapeToken.text);\n                        break;\n                    }\n                case \"html\":\n                    {\n                        const tagToken = token;\n                        out += renderer.html(tagToken.text);\n                        break;\n                    }\n                case \"link\":\n                    {\n                        const linkToken = token;\n                        out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                        break;\n                    }\n                case \"image\":\n                    {\n                        const imageToken = token;\n                        out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                        break;\n                    }\n                case \"strong\":\n                    {\n                        const strongToken = token;\n                        out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                        break;\n                    }\n                case \"em\":\n                    {\n                        const emToken = token;\n                        out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                        break;\n                    }\n                case \"codespan\":\n                    {\n                        const codespanToken = token;\n                        out += renderer.codespan(codespanToken.text);\n                        break;\n                    }\n                case \"br\":\n                    {\n                        out += renderer.br();\n                        break;\n                    }\n                case \"del\":\n                    {\n                        const delToken = token;\n                        out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                        break;\n                    }\n                case \"text\":\n                    {\n                        const textToken = token;\n                        out += renderer.text(textToken.text);\n                        break;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n}\nclass _Hooks {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    static{\n        this.passThroughHooks = new Set([\n            \"preprocess\",\n            \"postprocess\",\n            \"processAllTokens\"\n        ]);\n    }\n    /**\n     * Process markdown before marked\n     */ preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */ postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */ processAllTokens(tokens) {\n        return tokens;\n    }\n}\nclass Marked {\n    constructor(...args){\n        this.defaults = _getDefaults();\n        this.options = this.setOptions;\n        this.parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n        this.parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n        this.Parser = _Parser;\n        this.Renderer = _Renderer;\n        this.TextRenderer = _TextRenderer;\n        this.Lexer = _Lexer;\n        this.Tokenizer = _Tokenizer;\n        this.Hooks = _Hooks;\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */ walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens){\n            values = values.concat(callback.call(this, token));\n            switch(token.type){\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        for (const cell of tableToken.header){\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of tableToken.rows){\n                            for (const cell of row){\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        values = values.concat(this.walkTokens(listToken.items, callback));\n                        break;\n                    }\n                default:\n                    {\n                        const genericToken = token;\n                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{\n                                const tokens = genericToken[childTokens].flat(Infinity);\n                                values = values.concat(this.walkTokens(tokens, callback));\n                            });\n                        } else if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || {\n            renderers: {},\n            childTokens: {}\n        };\n        args.forEach((pack)=>{\n            // copy options to new object\n            const opts = {\n                ...pack\n            };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext)=>{\n                    if (!ext.name) {\n                        throw new Error(\"extension name required\");\n                    }\n                    if (\"renderer\" in ext) {\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function(...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        } else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if (\"tokenizer\" in ext) {\n                        if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        } else {\n                            extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                        }\n                        if (ext.start) {\n                            if (ext.level === \"block\") {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                } else {\n                                    extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                }\n                            } else if (ext.level === \"inline\") {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                } else {\n                                    extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                    }\n                    if (\"childTokens\" in ext && ext.childTokens) {\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for(const prop in pack.renderer){\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (prop === \"options\") {\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args)=>{\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || \"\";\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for(const prop in pack.tokenizer){\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if ([\n                        \"options\",\n                        \"rules\",\n                        \"lexer\"\n                    ].includes(prop)) {\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args)=>{\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for(const prop in pack.hooks){\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (prop === \"options\") {\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg)=>{\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret)=>{\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args)=>{\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function(token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = {\n                ...this.defaults,\n                ...opts\n            };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = {\n            ...this.defaults,\n            ...opt\n        };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    #parseMarkdown(lexer, parser) {\n        return (src, options)=>{\n            const origOpt = {\n                ...options\n            };\n            const opt = {\n                ...this.defaults,\n                ...origOpt\n            };\n            // Show warning if an extension set async to true but the parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                if (!opt.silent) {\n                    console.warn(\"marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.\");\n                }\n                opt.async = true;\n            }\n            const throwError = this.#onError(!!opt.silent, !!opt.async);\n            // throw error in case of non string input\n            if (typeof src === \"undefined\" || src === null) {\n                return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n            }\n            if (typeof src !== \"string\") {\n                return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n            }\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            } catch (e) {\n                return throwError(e);\n            }\n        };\n    }\n    #onError(silent, async) {\n        return (e)=>{\n            e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n            if (silent) {\n                const msg = \"<p>An error occurred:</p><pre>\" + escape$1(e.message + \"\", true) + \"</pre>\";\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\nconst markedInstance = new Marked();\nfunction marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */ marked.options = marked.setOptions = function(options) {\n    markedInstance.setOptions(options);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Gets the original marked default options.\n */ marked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */ marked.use = function(...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */ marked.walkTokens = function(tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */ marked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */ marked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\n //# sourceMappingURL=marked.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FFRDs7O0NBR0MsR0FFRDs7Q0FFQyxHQUNELFNBQVNBO0lBQ0wsT0FBTztRQUNIQyxPQUFPO1FBQ1BDLFFBQVE7UUFDUkMsWUFBWTtRQUNaQyxLQUFLO1FBQ0xDLE9BQU87UUFDUEMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsV0FBVztRQUNYQyxZQUFZO0lBQ2hCO0FBQ0o7QUFDQSxJQUFJQyxZQUFZWDtBQUNoQixTQUFTWSxlQUFlQyxXQUFXO0lBQy9CRixZQUFZRTtBQUNoQjtBQUVBOztDQUVDLEdBQ0QsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxnQkFBZ0IsSUFBSUMsT0FBT0YsV0FBV0csTUFBTSxFQUFFO0FBQ3BELE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyx3QkFBd0IsSUFBSUgsT0FBT0UsbUJBQW1CRCxNQUFNLEVBQUU7QUFDcEUsTUFBTUcscUJBQXFCO0lBQ3ZCLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0FBQ1Q7QUFDQSxNQUFNQyx1QkFBdUIsQ0FBQ0MsS0FBT0Ysa0JBQWtCLENBQUNFLEdBQUc7QUFDM0QsU0FBU0MsU0FBU0MsSUFBSSxFQUFFQyxNQUFNO0lBQzFCLElBQUlBLFFBQVE7UUFDUixJQUFJWCxXQUFXWSxJQUFJLENBQUNGLE9BQU87WUFDdkIsT0FBT0EsS0FBS0csT0FBTyxDQUFDWixlQUFlTTtRQUN2QztJQUNKLE9BQ0s7UUFDRCxJQUFJSCxtQkFBbUJRLElBQUksQ0FBQ0YsT0FBTztZQUMvQixPQUFPQSxLQUFLRyxPQUFPLENBQUNSLHVCQUF1QkU7UUFDL0M7SUFDSjtJQUNBLE9BQU9HO0FBQ1g7QUFDQSxNQUFNSSxlQUFlO0FBQ3JCLFNBQVNDLFNBQVNMLElBQUk7SUFDbEIseURBQXlEO0lBQ3pELE9BQU9B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T0FBTzdDLE1BQU0sR0FBR3hDO0FBQ2hCcUYsT0FBT2xGLE1BQU0sR0FBR0gsUUFBUUUsS0FBSztBQUM3Qm1GLE9BQU81QyxRQUFRLEdBQUcxRDtBQUNsQnNHLE9BQU8zQyxZQUFZLEdBQUczQztBQUN0QnNGLE9BQU8xQyxLQUFLLEdBQUczRjtBQUNmcUksT0FBT3RSLEtBQUssR0FBR2lKLE9BQU9JLEdBQUc7QUFDekJpSSxPQUFPekMsU0FBUyxHQUFHNU47QUFDbkJxUSxPQUFPeEMsS0FBSyxHQUFHakI7QUFDZnlELE9BQU9uRixLQUFLLEdBQUdtRjtBQUNmLE1BQU1uUSxVQUFVbVEsT0FBT25RLE9BQU87QUFDOUIsTUFBTW9OLGFBQWErQyxPQUFPL0MsVUFBVTtBQUNwQyxNQUFNUSxNQUFNdUMsT0FBT3ZDLEdBQUc7QUFDdEIsTUFBTTNULGFBQWFrVyxPQUFPbFcsVUFBVTtBQUNwQyxNQUFNaVIsY0FBY2lGLE9BQU9qRixXQUFXO0FBQ3RDLE1BQU1GLFFBQVFtRjtBQUNkLE1BQU1sRixTQUFTSCxRQUFRRSxLQUFLO0FBQzVCLE1BQU1uTSxRQUFRaUosT0FBT0ksR0FBRztBQUVtUSxDQUMzUixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYXJpYW0vLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzP2M3MzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBtYXJrZWQgdjExLjIuMCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAyNCwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWRcbiAqL1xuXG4vKipcbiAqIERPIE5PVCBFRElUIFRISVMgRklMRVxuICogVGhlIGNvZGUgaW4gdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIGZpbGVzIGluIC4vc3JjL1xuICovXG5cbi8qKlxuICogR2V0cyB0aGUgb3JpZ2luYWwgbWFya2VkIGRlZmF1bHQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgYnJlYWtzOiBmYWxzZSxcbiAgICAgICAgZXh0ZW5zaW9uczogbnVsbCxcbiAgICAgICAgZ2ZtOiB0cnVlLFxuICAgICAgICBob29rczogbnVsbCxcbiAgICAgICAgcGVkYW50aWM6IGZhbHNlLFxuICAgICAgICByZW5kZXJlcjogbnVsbCxcbiAgICAgICAgc2lsZW50OiBmYWxzZSxcbiAgICAgICAgdG9rZW5pemVyOiBudWxsLFxuICAgICAgICB3YWxrVG9rZW5zOiBudWxsXG4gICAgfTtcbn1cbmxldCBfZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbmZ1bmN0aW9uIGNoYW5nZURlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gICAgX2RlZmF1bHRzID0gbmV3RGVmYXVsdHM7XG59XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5jb25zdCBlc2NhcGVUZXN0ID0gL1smPD5cIiddLztcbmNvbnN0IGVzY2FwZVJlcGxhY2UgPSBuZXcgUmVnRXhwKGVzY2FwZVRlc3Quc291cmNlLCAnZycpO1xuY29uc3QgZXNjYXBlVGVzdE5vRW5jb2RlID0gL1s8PlwiJ118Jig/ISgjXFxkezEsN318I1tYeF1bYS1mQS1GMC05XXsxLDZ9fFxcdyspOykvO1xuY29uc3QgZXNjYXBlUmVwbGFjZU5vRW5jb2RlID0gbmV3IFJlZ0V4cChlc2NhcGVUZXN0Tm9FbmNvZGUuc291cmNlLCAnZycpO1xuY29uc3QgZXNjYXBlUmVwbGFjZW1lbnRzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xufTtcbmNvbnN0IGdldEVzY2FwZVJlcGxhY2VtZW50ID0gKGNoKSA9PiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xuZnVuY3Rpb24gZXNjYXBlJDEoaHRtbCwgZW5jb2RlKSB7XG4gICAgaWYgKGVuY29kZSkge1xuICAgICAgICBpZiAoZXNjYXBlVGVzdC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2VOb0VuY29kZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xufVxuY29uc3QgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcbmZ1bmN0aW9uIHVuZXNjYXBlKGh0bWwpIHtcbiAgICAvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXNcbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHVuZXNjYXBlVGVzdCwgKF8sIG4pID0+IHtcbiAgICAgICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKG4gPT09ICdjb2xvbicpXG4gICAgICAgICAgICByZXR1cm4gJzonO1xuICAgICAgICBpZiAobi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG59XG5jb25zdCBjYXJldCA9IC8oXnxbXlxcW10pXFxeL2c7XG5mdW5jdGlvbiBlZGl0KHJlZ2V4LCBvcHQpIHtcbiAgICBsZXQgc291cmNlID0gdHlwZW9mIHJlZ2V4ID09PSAnc3RyaW5nJyA/IHJlZ2V4IDogcmVnZXguc291cmNlO1xuICAgIG9wdCA9IG9wdCB8fCAnJztcbiAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIHJlcGxhY2U6IChuYW1lLCB2YWwpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWxTb3VyY2UgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IHZhbCA6IHZhbC5zb3VyY2U7XG4gICAgICAgICAgICB2YWxTb3VyY2UgPSB2YWxTb3VyY2UucmVwbGFjZShjYXJldCwgJyQxJyk7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZShuYW1lLCB2YWxTb3VyY2UpO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UmVnZXg6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgb3B0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGNsZWFuVXJsKGhyZWYpIHtcbiAgICB0cnkge1xuICAgICAgICBocmVmID0gZW5jb2RlVVJJKGhyZWYpLnJlcGxhY2UoLyUyNS9nLCAnJScpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGhyZWY7XG59XG5jb25zdCBub29wVGVzdCA9IHsgZXhlYzogKCkgPT4gbnVsbCB9O1xuZnVuY3Rpb24gc3BsaXRDZWxscyh0YWJsZVJvdywgY291bnQpIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBldmVyeSBjZWxsLWRlbGltaXRpbmcgcGlwZSBoYXMgYSBzcGFjZVxuICAgIC8vIGJlZm9yZSBpdCB0byBkaXN0aW5ndWlzaCBpdCBmcm9tIGFuIGVzY2FwZWQgcGlwZVxuICAgIGNvbnN0IHJvdyA9IHRhYmxlUm93LnJlcGxhY2UoL1xcfC9nLCAobWF0Y2gsIG9mZnNldCwgc3RyKSA9PiB7XG4gICAgICAgIGxldCBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBjdXJyID0gb2Zmc2V0O1xuICAgICAgICB3aGlsZSAoLS1jdXJyID49IDAgJiYgc3RyW2N1cnJdID09PSAnXFxcXCcpXG4gICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgICAgICAvLyBvZGQgbnVtYmVyIG9mIHNsYXNoZXMgbWVhbnMgfCBpcyBlc2NhcGVkXG4gICAgICAgICAgICAvLyBzbyB3ZSBsZWF2ZSBpdCBhbG9uZVxuICAgICAgICAgICAgcmV0dXJuICd8JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFkZCBzcGFjZSBiZWZvcmUgdW5lc2NhcGVkIHxcbiAgICAgICAgICAgIHJldHVybiAnIHwnO1xuICAgICAgICB9XG4gICAgfSksIGNlbGxzID0gcm93LnNwbGl0KC8gXFx8Lyk7XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEZpcnN0L2xhc3QgY2VsbCBpbiBhIHJvdyBjYW5ub3QgYmUgZW1wdHkgaWYgaXQgaGFzIG5vIGxlYWRpbmcvdHJhaWxpbmcgcGlwZVxuICAgIGlmICghY2VsbHNbMF0udHJpbSgpKSB7XG4gICAgICAgIGNlbGxzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmIChjZWxscy5sZW5ndGggPiAwICYmICFjZWxsc1tjZWxscy5sZW5ndGggLSAxXS50cmltKCkpIHtcbiAgICAgICAgY2VsbHMucG9wKCk7XG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgICBpZiAoY2VsbHMubGVuZ3RoID4gY291bnQpIHtcbiAgICAgICAgICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoY2VsbHMubGVuZ3RoIDwgY291bnQpXG4gICAgICAgICAgICAgICAgY2VsbHMucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgaXMgaWdub3JlZCBwZXIgdGhlIGdmbSBzcGVjXG4gICAgICAgIGNlbGxzW2ldID0gY2VsbHNbaV0udHJpbSgpLnJlcGxhY2UoL1xcXFxcXHwvZywgJ3wnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGxzO1xufVxuLyoqXG4gKiBSZW1vdmUgdHJhaWxpbmcgJ2Mncy4gRXF1aXZhbGVudCB0byBzdHIucmVwbGFjZSgvYyokLywgJycpLlxuICogL2MqJC8gaXMgdnVsbmVyYWJsZSB0byBSRURPUy5cbiAqXG4gKiBAcGFyYW0gc3RyXG4gKiBAcGFyYW0gY1xuICogQHBhcmFtIGludmVydCBSZW1vdmUgc3VmZml4IG9mIG5vbi1jIGNoYXJzIGluc3RlYWQuIERlZmF1bHQgZmFsc2V5LlxuICovXG5mdW5jdGlvbiBydHJpbShzdHIsIGMsIGludmVydCkge1xuICAgIGNvbnN0IGwgPSBzdHIubGVuZ3RoO1xuICAgIGlmIChsID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgLy8gTGVuZ3RoIG9mIHN1ZmZpeCBtYXRjaGluZyB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgICBsZXQgc3VmZkxlbiA9IDA7XG4gICAgLy8gU3RlcCBsZWZ0IHVudGlsIHdlIGZhaWwgdG8gbWF0Y2ggdGhlIGludmVydCBjb25kaXRpb24uXG4gICAgd2hpbGUgKHN1ZmZMZW4gPCBsKSB7XG4gICAgICAgIGNvbnN0IGN1cnJDaGFyID0gc3RyLmNoYXJBdChsIC0gc3VmZkxlbiAtIDEpO1xuICAgICAgICBpZiAoY3VyckNoYXIgPT09IGMgJiYgIWludmVydCkge1xuICAgICAgICAgICAgc3VmZkxlbisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJDaGFyICE9PSBjICYmIGludmVydCkge1xuICAgICAgICAgICAgc3VmZkxlbisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zbGljZSgwLCBsIC0gc3VmZkxlbik7XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2luZ0JyYWNrZXQoc3RyLCBiKSB7XG4gICAgaWYgKHN0ci5pbmRleE9mKGJbMV0pID09PSAtMSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGxldCBsZXZlbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cltpXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyW2ldID09PSBiWzBdKSB7XG4gICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0cltpXSA9PT0gYlsxXSkge1xuICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIG91dHB1dExpbmsoY2FwLCBsaW5rLCByYXcsIGxleGVyKSB7XG4gICAgY29uc3QgaHJlZiA9IGxpbmsuaHJlZjtcbiAgICBjb25zdCB0aXRsZSA9IGxpbmsudGl0bGUgPyBlc2NhcGUkMShsaW5rLnRpdGxlKSA6IG51bGw7XG4gICAgY29uc3QgdGV4dCA9IGNhcFsxXS5yZXBsYWNlKC9cXFxcKFtcXFtcXF1dKS9nLCAnJDEnKTtcbiAgICBpZiAoY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnKSB7XG4gICAgICAgIGxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpXG4gICAgICAgIH07XG4gICAgICAgIGxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgIHJhdyxcbiAgICAgICAgaHJlZixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHRleHQ6IGVzY2FwZSQxKHRleHQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCB0ZXh0KSB7XG4gICAgY29uc3QgbWF0Y2hJbmRlbnRUb0NvZGUgPSByYXcubWF0Y2goL14oXFxzKykoPzpgYGApLyk7XG4gICAgaWYgKG1hdGNoSW5kZW50VG9Db2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRUb0NvZGUgPSBtYXRjaEluZGVudFRvQ29kZVsxXTtcbiAgICByZXR1cm4gdGV4dFxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoSW5kZW50SW5Ob2RlID0gbm9kZS5tYXRjaCgvXlxccysvKTtcbiAgICAgICAgaWYgKG1hdGNoSW5kZW50SW5Ob2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaW5kZW50SW5Ob2RlXSA9IG1hdGNoSW5kZW50SW5Ob2RlO1xuICAgICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zbGljZShpbmRlbnRUb0NvZGUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vKipcbiAqIFRva2VuaXplclxuICovXG5jbGFzcyBfVG9rZW5pemVyIHtcbiAgICBvcHRpb25zO1xuICAgIHJ1bGVzOyAvLyBzZXQgYnkgdGhlIGxleGVyXG4gICAgbGV4ZXI7IC8vIHNldCBieSB0aGUgbGV4ZXJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgIH1cbiAgICBzcGFjZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCAmJiBjYXBbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3BhY2UnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvZGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suY29kZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgY29kZUJsb2NrU3R5bGU6ICdpbmRlbnRlZCcsXG4gICAgICAgICAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgICAgICAgICA/IHJ0cmltKHRleHQsICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICA6IHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmVuY2VzKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmZlbmNlcy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHJhdyA9IGNhcFswXTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgY2FwWzNdIHx8ICcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICBsYW5nOiBjYXBbMl0gPyBjYXBbMl0udHJpbSgpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sICckMScpIDogY2FwWzJdLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGVhZGluZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0udHJpbSgpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICBpZiAoLyMkLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHJ0cmltKHRleHQsICcjJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0cmltbWVkIHx8IC8gJC8udGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21tb25NYXJrIHJlcXVpcmVzIHNwYWNlIGJlZm9yZSB0cmFpbGluZyAjc1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhyKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhyLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHInLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGJsb2NrcXVvdGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suYmxvY2txdW90ZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBydHJpbShjYXBbMF0ucmVwbGFjZSgvXiAqPlsgXFx0XT8vZ20sICcnKSwgJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5sZXhlci5zdGF0ZS50b3A7XG4gICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmxleGVyLmJsb2NrVG9rZW5zKHRleHQpO1xuICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSB0b3A7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaXN0KHNyYykge1xuICAgICAgICBsZXQgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saXN0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IGJ1bGwgPSBjYXBbMV0udHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgaXNvcmRlcmVkID0gYnVsbC5sZW5ndGggPiAxO1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgICAgICAgcmF3OiAnJyxcbiAgICAgICAgICAgICAgICBvcmRlcmVkOiBpc29yZGVyZWQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGlzb3JkZXJlZCA/ICtidWxsLnNsaWNlKDAsIC0xKSA6ICcnLFxuICAgICAgICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBidWxsID0gaXNvcmRlcmVkID8gYFxcXFxkezEsOX1cXFxcJHtidWxsLnNsaWNlKC0xKX1gIDogYFxcXFwke2J1bGx9YDtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICBidWxsID0gaXNvcmRlcmVkID8gYnVsbCA6ICdbKistXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgbmV4dCBsaXN0IGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1SZWdleCA9IG5ldyBSZWdFeHAoYF4oIHswLDN9JHtidWxsfSkoKD86W1xcdCBdW15cXFxcbl0qKT8oPzpcXFxcbnwkKSlgKTtcbiAgICAgICAgICAgIGxldCByYXcgPSAnJztcbiAgICAgICAgICAgIGxldCBpdGVtQ29udGVudHMgPSAnJztcbiAgICAgICAgICAgIGxldCBlbmRzV2l0aEJsYW5rTGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgY3VycmVudCBidWxsZXQgcG9pbnQgY2FuIHN0YXJ0IGEgbmV3IExpc3QgSXRlbVxuICAgICAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgICAgIGxldCBlbmRFYXJseSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghKGNhcCA9IGl0ZW1SZWdleC5leGVjKHNyYykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHsgLy8gRW5kIGxpc3QgaWYgYnVsbGV0IHdhcyBhY3R1YWxseSBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByYXcgPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhyYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGNhcFsyXS5zcGxpdCgnXFxuJywgMSlbMF0ucmVwbGFjZSgvXlxcdCsvLCAodCkgPT4gJyAnLnJlcGVhdCgzICogdC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dExpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IGNhcFsyXS5zZWFyY2goL1teIF0vKTsgLy8gRmluZCBmaXJzdCBub24tc3BhY2UgY2hhclxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSBpbmRlbnQgPiA0ID8gMSA6IGluZGVudDsgLy8gVHJlYXQgaW5kZW50ZWQgY29kZSBibG9ja3MgKD4gNCBzcGFjZXMpIGFzIGhhdmluZyBvbmx5IDEgaW5kZW50XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IGNhcFsxXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBibGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmUgJiYgL14gKiQvLnRlc3QobmV4dExpbmUpKSB7IC8vIEl0ZW1zIGJlZ2luIHdpdGggYXQgbW9zdCBvbmUgYmxhbmsgbGluZVxuICAgICAgICAgICAgICAgICAgICByYXcgKz0gbmV4dExpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhuZXh0TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kRWFybHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVuZEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRCdWxsZXRSZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19KD86WyorLV18XFxcXGR7MSw5fVsuKV0pKCg/OlsgXFx0XVteXFxcXG5dKik/KD86XFxcXG58JCkpYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhyUmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlbmNlc0JlZ2luUmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlxcYFxcYFxcYHx+fn4pYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdCZWdpblJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0jYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvbGxvd2luZyBsaW5lcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gTGlzdCBJdGVtXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd0xpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSByYXdMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmUtYWxpZ24gdG8gZm9sbG93IGNvbW1vbm1hcmsgbmVzdGluZyBydWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gbmV4dExpbmUucmVwbGFjZSgvXiB7MSw0fSg/PSggezR9KSpbXiBdKS9nLCAnICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgY29kZSBmZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZW5jZXNCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBoZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGluZ0JlZ2luUmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgc3RhcnQgb2YgbmV3IGJ1bGxldFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRCdWxsZXRSZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBydWxlIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KHNyYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TGluZS5zZWFyY2goL1teIF0vKSA+PSBpbmRlbnQgfHwgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBEZWRlbnQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgKz0gJ1xcbicgKyBuZXh0TGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibGFua0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmFncmFwaCBjb250aW51YXRpb24gdW5sZXNzIGxhc3QgbGluZSB3YXMgYSBkaWZmZXJlbnQgYmxvY2sgbGV2ZWwgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnNlYXJjaCgvW14gXS8pID49IDQpIHsgLy8gaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlbmNlc0JlZ2luUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibGFua0xpbmUgJiYgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBDaGVjayBpZiBjdXJyZW50IGxpbmUgaXMgYmxhbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3ICs9IHJhd0xpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBuZXh0TGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbGlzdC5sb29zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgaXRlbSBlbmRlZCB3aXRoIGEgYmxhbmsgbGluZSwgdGhlIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXFxuICpcXG4gKiQvLnRlc3QocmF3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kc1dpdGhCbGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpc3Rhc2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBpc2NoZWNrZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc3Rhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzY2hlY2tlZCA9IGlzdGFza1swXSAhPT0gJ1sgXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gaXRlbUNvbnRlbnRzLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW0nLFxuICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgIHRhc2s6ICEhaXN0YXNrLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaXRlbUNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGlzdC5yYXcgKz0gcmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IGNvbnN1bWUgbmV3bGluZXMgYXQgZW5kIG9mIGZpbmFsIGl0ZW0uIEFsdGVybmF0aXZlbHksIG1ha2UgaXRlbVJlZ2V4ICpzdGFydCogd2l0aCBhbnkgbmV3bGluZXMgdG8gc2ltcGxpZnkvc3BlZWQgdXAgZW5kc1dpdGhCbGFua0xpbmUgbG9naWNcbiAgICAgICAgICAgIGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXS5yYXcgPSByYXcudHJpbUVuZCgpO1xuICAgICAgICAgICAgKGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXSkudGV4dCA9IGl0ZW1Db250ZW50cy50cmltRW5kKCk7XG4gICAgICAgICAgICBsaXN0LnJhdyA9IGxpc3QucmF3LnRyaW1FbmQoKTtcbiAgICAgICAgICAgIC8vIEl0ZW0gY2hpbGQgdG9rZW5zIGhhbmRsZWQgaGVyZSBhdCBlbmQgYmVjYXVzZSB3ZSBuZWVkZWQgdG8gaGF2ZSB0aGUgZmluYWwgaXRlbSB0byB0cmltIGl0IGZpcnN0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxpc3QuaXRlbXNbaV0udG9rZW5zID0gdGhpcy5sZXhlci5ibG9ja1Rva2VucyhsaXN0Lml0ZW1zW2ldLnRleHQsIFtdKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3QubG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbGlzdCBzaG91bGQgYmUgbG9vc2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhY2VycyA9IGxpc3QuaXRlbXNbaV0udG9rZW5zLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gJ3NwYWNlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc011bHRpcGxlTGluZUJyZWFrcyA9IHNwYWNlcnMubGVuZ3RoID4gMCAmJiBzcGFjZXJzLnNvbWUodCA9PiAvXFxuLipcXG4vLnRlc3QodC5yYXcpKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5sb29zZSA9IGhhc011bHRpcGxlTGluZUJyZWFrcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgYWxsIGl0ZW1zIHRvIGxvb3NlIGlmIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgIGlmIChsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuaXRlbXNbaV0ubG9vc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGh0bWwoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHRtbC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBwcmU6IGNhcFsxXSA9PT0gJ3ByZScgfHwgY2FwWzFdID09PSAnc2NyaXB0JyB8fCBjYXBbMV0gPT09ICdzdHlsZScsXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlZihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5kZWYuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBjYXBbMV0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gY2FwWzJdID8gY2FwWzJdLnJlcGxhY2UoL148KC4qKT4kLywgJyQxJykucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnN1YnN0cmluZygxLCBjYXBbM10ubGVuZ3RoIC0gMSkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiBjYXBbM107XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkZWYnLFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHRpdGxlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhYmxlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRhYmxlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIS9bOnxdLy50ZXN0KGNhcFsyXSkpIHtcbiAgICAgICAgICAgIC8vIGRlbGltaXRlciByb3cgbXVzdCBoYXZlIGEgcGlwZSAofCkgb3IgY29sb24gKDopIG90aGVyd2lzZSBpdCBpcyBhIHNldGV4dCBoZWFkaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHNwbGl0Q2VsbHMoY2FwWzFdKTtcbiAgICAgICAgY29uc3QgYWxpZ25zID0gY2FwWzJdLnJlcGxhY2UoL15cXHx8XFx8ICokL2csICcnKS5zcGxpdCgnfCcpO1xuICAgICAgICBjb25zdCByb3dzID0gY2FwWzNdICYmIGNhcFszXS50cmltKCkgPyBjYXBbM10ucmVwbGFjZSgvXFxuWyBcXHRdKiQvLCAnJykuc3BsaXQoJ1xcbicpIDogW107XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICBoZWFkZXI6IFtdLFxuICAgICAgICAgICAgYWxpZ246IFtdLFxuICAgICAgICAgICAgcm93czogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoICE9PSBhbGlnbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBoZWFkZXIgYW5kIGFsaWduIGNvbHVtbnMgbXVzdCBiZSBlcXVhbCwgcm93cyBjYW4gYmUgZGlmZmVyZW50LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgYWxpZ24gb2YgYWxpZ25zKSB7XG4gICAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFsaWduLnB1c2goJ3JpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFsaWduLnB1c2goJ2NlbnRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFsaWduLnB1c2goJ2xlZnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ24ucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpdGVtLmhlYWRlci5wdXNoKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBoZWFkZXIsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShoZWFkZXIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICBpdGVtLnJvd3MucHVzaChzcGxpdENlbGxzKHJvdywgaXRlbS5oZWFkZXIubGVuZ3RoKS5tYXAoY2VsbCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY2VsbCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShjZWxsKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIGxoZWFkaW5nKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsyXS5jaGFyQXQoMCkgPT09ICc9JyA/IDEgOiAyLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFsxXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFsxXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYWdyYXBoKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnBhcmFncmFwaC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbidcbiAgICAgICAgICAgICAgICA/IGNhcFsxXS5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgICAgICA6IGNhcFsxXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRleHQoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGV4dC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFswXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXNjYXBlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGVzY2FwZSQxKGNhcFsxXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFnKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50YWcuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgJiYgL148KHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgJiYgL148XFwvKHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgaW5MaW5rOiB0aGlzLmxleGVyLnN0YXRlLmluTGluayxcbiAgICAgICAgICAgICAgICBpblJhd0Jsb2NrOiB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2ssXG4gICAgICAgICAgICAgICAgYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaW5rKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wZWRhbnRpYyAmJiAvXjwvLnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21tb25tYXJrIHJlcXVpcmVzIG1hdGNoaW5nIGFuZ2xlIGJyYWNrZXRzXG4gICAgICAgICAgICAgICAgaWYgKCEoLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuZGluZyBhbmdsZSBicmFja2V0IGNhbm5vdCBiZSBlc2NhcGVkXG4gICAgICAgICAgICAgICAgY29uc3QgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuICAgICAgICAgICAgICAgIGlmICgodHJpbW1lZFVybC5sZW5ndGggLSBydHJpbVNsYXNoLmxlbmd0aCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sICcoKScpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhyZWYgPSBjYXBbMl07XG4gICAgICAgICAgICBsZXQgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCBwZWRhbnRpYyBocmVmIGFuZCB0aXRsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8uZXhlYyhocmVmKTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBsaW5rWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHJlZiA9IGhyZWYudHJpbSgpO1xuICAgICAgICAgICAgaWYgKC9ePC8udGVzdChocmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgISgvPiQvLnRlc3QodHJpbW1lZFVybCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBlZGFudGljIGFsbG93cyBzdGFydGluZyBhbmdsZSBicmFja2V0IHdpdGhvdXQgZW5kaW5nIGFuZ2xlIGJyYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgICAgICAgICAgaHJlZjogaHJlZiA/IGhyZWYucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiBocmVmLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSA/IHRpdGxlLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sICckMScpIDogdGl0bGVcbiAgICAgICAgICAgIH0sIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmbGluayhzcmMsIGxpbmtzKSB7XG4gICAgICAgIGxldCBjYXA7XG4gICAgICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtTdHJpbmcgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgICAgICAgY29uc3QgbGluayA9IGxpbmtzW2xpbmtTdHJpbmcudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIGxpbmssIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyID0gJycpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmdMRGVsaW0uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBfIGNhbid0IGJlIGJldHdlZW4gdHdvIGFscGhhbnVtZXJpY3MuIFxccHtMfVxccHtOfSBpbmNsdWRlcyBub24tZW5nbGlzaCBhbHBoYWJldC9udW1iZXJzIGFzIHdlbGxcbiAgICAgICAgaWYgKG1hdGNoWzNdICYmIHByZXZDaGFyLm1hdGNoKC9bXFxwe0x9XFxwe059XS91KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbmV4dENoYXIgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCAnJztcbiAgICAgICAgaWYgKCFuZXh0Q2hhciB8fCAhcHJldkNoYXIgfHwgdGhpcy5ydWxlcy5pbmxpbmUucHVuY3R1YXRpb24uZXhlYyhwcmV2Q2hhcikpIHtcbiAgICAgICAgICAgIC8vIHVuaWNvZGUgUmVnZXggY291bnRzIGVtb2ppIGFzIDEgY2hhcjsgc3ByZWFkIGludG8gYXJyYXkgZm9yIHByb3BlciBjb3VudCAodXNlZCBtdWx0aXBsZSB0aW1lcyBiZWxvdylcbiAgICAgICAgICAgIGNvbnN0IGxMZW5ndGggPSBbLi4ubWF0Y2hbMF1dLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgckRlbGltLCByTGVuZ3RoLCBkZWxpbVRvdGFsID0gbExlbmd0aCwgbWlkRGVsaW1Ub3RhbCA9IDA7XG4gICAgICAgICAgICBjb25zdCBlbmRSZWcgPSBtYXRjaFswXVswXSA9PT0gJyonID8gdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmdSRGVsaW1Bc3QgOiB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZ1JEZWxpbVVuZDtcbiAgICAgICAgICAgIGVuZFJlZy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgLy8gQ2xpcCBtYXNrZWRTcmMgdG8gc2FtZSBzZWN0aW9uIG9mIHN0cmluZyBhcyBzcmMgKG1vdmUgdG8gbGV4ZXI/KVxuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKC0xICogc3JjLmxlbmd0aCArIGxMZW5ndGgpO1xuICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IGVuZFJlZy5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByRGVsaW0gPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBtYXRjaFs2XTtcbiAgICAgICAgICAgICAgICBpZiAoIXJEZWxpbSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgc2luZ2xlICogaW4gX19hYmMqYWJjX19cbiAgICAgICAgICAgICAgICByTGVuZ3RoID0gWy4uLnJEZWxpbV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFszXSB8fCBtYXRjaFs0XSkgeyAvLyBmb3VuZCBhbm90aGVyIExlZnQgRGVsaW1cbiAgICAgICAgICAgICAgICAgICAgZGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hbNV0gfHwgbWF0Y2hbNl0pIHsgLy8gZWl0aGVyIExlZnQgb3IgUmlnaHQgRGVsaW1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxMZW5ndGggJSAzICYmICEoKGxMZW5ndGggKyByTGVuZ3RoKSAlIDMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaWREZWxpbVRvdGFsICs9IHJMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gQ29tbW9uTWFyayBFbXBoYXNpcyBSdWxlcyA5LTEwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsaW1Ub3RhbCAtPSByTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChkZWxpbVRvdGFsID4gMClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIEhhdmVuJ3QgZm91bmQgZW5vdWdoIGNsb3NpbmcgZGVsaW1pdGVyc1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBleHRyYSBjaGFyYWN0ZXJzLiAqYSoqKiAtPiAqYSpcbiAgICAgICAgICAgICAgICByTGVuZ3RoID0gTWF0aC5taW4ockxlbmd0aCwgckxlbmd0aCArIGRlbGltVG90YWwgKyBtaWREZWxpbVRvdGFsKTtcbiAgICAgICAgICAgICAgICAvLyBjaGFyIGxlbmd0aCBjYW4gYmUgPjEgZm9yIHVuaWNvZGUgY2hhcmFjdGVycztcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q2hhckxlbmd0aCA9IFsuLi5tYXRjaFswXV1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdyA9IHNyYy5zbGljZSgwLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyBsYXN0Q2hhckxlbmd0aCArIHJMZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBgZW1gIGlmIHNtYWxsZXN0IGRlbGltaXRlciBoYXMgb2RkIGNoYXIgY291bnQuICphKioqXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgubWluKGxMZW5ndGgsIHJMZW5ndGgpICUgMikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gcmF3LnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2Vucyh0ZXh0KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgJ3N0cm9uZycgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBldmVuIGNoYXIgY291bnQuICoqYSoqKlxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSByYXcuc2xpY2UoMiwgLTIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvZGVzcGFuKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5jb2RlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0ucmVwbGFjZSgvXFxuL2csICcgJyk7XG4gICAgICAgICAgICBjb25zdCBoYXNOb25TcGFjZUNoYXJzID0gL1teIF0vLnRlc3QodGV4dCk7XG4gICAgICAgICAgICBjb25zdCBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyA9IC9eIC8udGVzdCh0ZXh0KSAmJiAvICQvLnRlc3QodGV4dCk7XG4gICAgICAgICAgICBpZiAoaGFzTm9uU3BhY2VDaGFycyAmJiBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcykge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSQxKHRleHQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZXNwYW4nLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnIoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmJyLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnInLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZGVsLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVsJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMl0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2VucyhjYXBbMl0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGF1dG9saW5rKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0LCBocmVmO1xuICAgICAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSQxKGNhcFsxXSk7XG4gICAgICAgICAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlJDEoY2FwWzFdKTtcbiAgICAgICAgICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0b2tlbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmwoc3JjKSB7XG4gICAgICAgIGxldCBjYXA7XG4gICAgICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS51cmwuZXhlYyhzcmMpKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCwgaHJlZjtcbiAgICAgICAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUkMShjYXBbMF0pO1xuICAgICAgICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gZXh0ZW5kZWQgYXV0b2xpbmsgcGF0aCB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgbGV0IHByZXZDYXBaZXJvO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldkNhcFplcm8gPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgICAgIGNhcFswXSA9IHRoaXMucnVsZXMuaW5saW5lLl9iYWNrcGVkYWwuZXhlYyhjYXBbMF0pPy5bMF0gPz8gJyc7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSQxKGNhcFswXSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSAnaHR0cDovLycgKyBjYXBbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0b2tlbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmxpbmVUZXh0KHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50ZXh0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGNhcFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUkMShjYXBbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gKi9cbmNvbnN0IG5ld2xpbmUgPSAvXig/OiAqKD86XFxufCQpKSsvO1xuY29uc3QgYmxvY2tDb2RlID0gL14oIHs0fVteXFxuXSsoPzpcXG4oPzogKig/OlxcbnwkKSkqKT8pKy87XG5jb25zdCBmZW5jZXMgPSAvXiB7MCwzfShgezMsfSg/PVteYFxcbl0qKD86XFxufCQpKXx+ezMsfSkoW15cXG5dKikoPzpcXG58JCkoPzp8KFtcXHNcXFNdKj8pKD86XFxufCQpKSg/OiB7MCwzfVxcMVt+YF0qICooPz1cXG58JCl8JCkvO1xuY29uc3QgaHIgPSAvXiB7MCwzfSgoPzotW1xcdCBdKil7Myx9fCg/Ol9bIFxcdF0qKXszLH18KD86XFwqWyBcXHRdKil7Myx9KSg/Olxcbit8JCkvO1xuY29uc3QgaGVhZGluZyA9IC9eIHswLDN9KCN7MSw2fSkoPz1cXHN8JCkoLiopKD86XFxuK3wkKS87XG5jb25zdCBidWxsZXQgPSAvKD86WyorLV18XFxkezEsOX1bLildKS87XG5jb25zdCBsaGVhZGluZyA9IGVkaXQoL14oPyFidWxsICkoKD86LnxcXG4oPyFcXHMqP1xcbnxidWxsICkpKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8pXG4gICAgLnJlcGxhY2UoL2J1bGwvZywgYnVsbGV0KSAvLyBsaXN0cyBjYW4gaW50ZXJydXB0XG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfcGFyYWdyYXBoID0gL14oW15cXG5dKyg/Olxcbig/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXxmZW5jZXN8bGlzdHxodG1sfHRhYmxlfCArXFxuKVteXFxuXSspKikvO1xuY29uc3QgYmxvY2tUZXh0ID0gL15bXlxcbl0rLztcbmNvbnN0IF9ibG9ja0xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXC58W15cXFtcXF1cXFxcXSkrLztcbmNvbnN0IGRlZiA9IGVkaXQoL14gezAsM31cXFsobGFiZWwpXFxdOiAqKD86XFxuICopPyhbXjxcXHNdW15cXHNdKnw8Lio/PikoPzooPzogKyg/OlxcbiAqKT98ICpcXG4gKikodGl0bGUpKT8gKig/Olxcbit8JCkvKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9ibG9ja0xhYmVsKVxuICAgIC5yZXBsYWNlKCd0aXRsZScsIC8oPzpcIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnW14nXFxuXSooPzpcXG5bXidcXG5dKykqXFxuPyd8XFwoW14oKV0qXFwpKS8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBsaXN0ID0gZWRpdCgvXiggezAsM31idWxsKShbIFxcdF1bXlxcbl0rPyk/KD86XFxufCQpLylcbiAgICAucmVwbGFjZSgvYnVsbC9nLCBidWxsZXQpXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfdGFnID0gJ2FkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9uJ1xuICAgICsgJ3xjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbidcbiAgICArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZSdcbiAgICArICd8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG1ldGF8bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbidcbiAgICArICd8cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyJ1xuICAgICsgJ3x0cmFja3x1bCc7XG5jb25zdCBfY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuY29uc3QgaHRtbCA9IGVkaXQoJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qPyg/OlxcXFxdXFxcXF0+XFxcXG4qfCQpJyAvLyAoNSlcbiAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDYpXG4gICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBvcGVuIHRhZ1xuICAgICsgJ3w8Lyg/IXNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgKyAnKScsICdpJylcbiAgICAucmVwbGFjZSgnY29tbWVudCcsIF9jb21tZW50KVxuICAgIC5yZXBsYWNlKCd0YWcnLCBfdGFnKVxuICAgIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvICtbYS16QS1aOl9dW1xcdy46LV0qKD86ICo9ICpcIlteXCJcXG5dKlwifCAqPSAqJ1teJ1xcbl0qJ3wgKj0gKlteXFxzXCInPTw+YF0rKT8vKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgcGFyYWdyYXBoID0gZWRpdChfcGFyYWdyYXBoKVxuICAgIC5yZXBsYWNlKCdocicsIGhyKVxuICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSg/OlxcXFxzfCQpJylcbiAgICAucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4IGhlYWRpbmdzIGRvbid0IGludGVycnVwdCBjb21tb25tYXJrIHBhcmFncmFwaHNcbiAgICAucmVwbGFjZSgnfHRhYmxlJywgJycpXG4gICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAgIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gICAgLnJlcGxhY2UoJ3RhZycsIF90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBibG9ja3F1b3RlID0gZWRpdCgvXiggezAsM30+ID8ocGFyYWdyYXBofFteXFxuXSopKD86XFxufCQpKSsvKVxuICAgIC5yZXBsYWNlKCdwYXJhZ3JhcGgnLCBwYXJhZ3JhcGgpXG4gICAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gKi9cbmNvbnN0IGJsb2NrTm9ybWFsID0ge1xuICAgIGJsb2NrcXVvdGUsXG4gICAgY29kZTogYmxvY2tDb2RlLFxuICAgIGRlZixcbiAgICBmZW5jZXMsXG4gICAgaGVhZGluZyxcbiAgICBocixcbiAgICBodG1sLFxuICAgIGxoZWFkaW5nLFxuICAgIGxpc3QsXG4gICAgbmV3bGluZSxcbiAgICBwYXJhZ3JhcGgsXG4gICAgdGFibGU6IG5vb3BUZXN0LFxuICAgIHRleHQ6IGJsb2NrVGV4dFxufTtcbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuY29uc3QgZ2ZtVGFibGUgPSBlZGl0KCdeICooW15cXFxcbiBdLiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfSgoPzpcXFxcfCAqKT86Py0rOj8gKig/OlxcXFx8ICo6Py0rOj8gKikqKD86XFxcXHwgKik/KScgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScpIC8vIENlbGxzXG4gICAgLnJlcGxhY2UoJ2hyJywgaHIpXG4gICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9KD86XFxcXHN8JCknKVxuICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgIC5yZXBsYWNlKCdjb2RlJywgJyB7NH1bXlxcXFxuXScpXG4gICAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAgIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gICAgLnJlcGxhY2UoJ3RhZycsIF90YWcpIC8vIHRhYmxlcyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGJsb2NrR2ZtID0ge1xuICAgIC4uLmJsb2NrTm9ybWFsLFxuICAgIHRhYmxlOiBnZm1UYWJsZSxcbiAgICBwYXJhZ3JhcGg6IGVkaXQoX3BhcmFncmFwaClcbiAgICAgICAgLnJlcGxhY2UoJ2hyJywgaHIpXG4gICAgICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSg/OlxcXFxzfCQpJylcbiAgICAgICAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gICAgICAgIC5yZXBsYWNlKCd0YWJsZScsIGdmbVRhYmxlKSAvLyBpbnRlcnJ1cHQgcGFyYWdyYXBocyB3aXRoIHRhYmxlXG4gICAgICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgICAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gICAgICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgICAgICAucmVwbGFjZSgndGFnJywgX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgICAgICAgLmdldFJlZ2V4KClcbn07XG4vKipcbiAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAqL1xuY29uc3QgYmxvY2tQZWRhbnRpYyA9IHtcbiAgICAuLi5ibG9ja05vcm1hbCxcbiAgICBodG1sOiBlZGl0KCdeICooPzpjb21tZW50ICooPzpcXFxcbnxcXFxccyokKSdcbiAgICAgICAgKyAnfDwodGFnKVtcXFxcc1xcXFxTXSs/PC9cXFxcMT4gKig/OlxcXFxuezIsfXxcXFxccyokKScgLy8gY2xvc2VkIHRhZ1xuICAgICAgICArICd8PHRhZyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xcXFxcc1teXFwnXCIvPlxcXFxzXSopKj8vPz4gKig/OlxcXFxuezIsfXxcXFxccyokKSknKVxuICAgICAgICAucmVwbGFjZSgnY29tbWVudCcsIF9jb21tZW50KVxuICAgICAgICAucmVwbGFjZSgvdGFnL2csICcoPyEoPzonXG4gICAgICAgICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInXG4gICAgICAgICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJ1xuICAgICAgICArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArKFtcIihdW15cXG5dK1tcIildKSk/ICooPzpcXG4rfCQpLyxcbiAgICBoZWFkaW5nOiAvXigjezEsNn0pKC4qKSg/Olxcbit8JCkvLFxuICAgIGZlbmNlczogbm9vcFRlc3QsIC8vIGZlbmNlcyBub3Qgc3VwcG9ydGVkXG4gICAgbGhlYWRpbmc6IC9eKC4rPylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgICBwYXJhZ3JhcGg6IGVkaXQoX3BhcmFncmFwaClcbiAgICAgICAgLnJlcGxhY2UoJ2hyJywgaHIpXG4gICAgICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyAqI3sxLDZ9ICpbXlxcbl0nKVxuICAgICAgICAucmVwbGFjZSgnbGhlYWRpbmcnLCBsaGVhZGluZylcbiAgICAgICAgLnJlcGxhY2UoJ3x0YWJsZScsICcnKVxuICAgICAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAgICAgLnJlcGxhY2UoJ3xmZW5jZXMnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ3xsaXN0JywgJycpXG4gICAgICAgIC5yZXBsYWNlKCd8aHRtbCcsICcnKVxuICAgICAgICAucmVwbGFjZSgnfHRhZycsICcnKVxuICAgICAgICAuZ2V0UmVnZXgoKVxufTtcbi8qKlxuICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAqL1xuY29uc3QgZXNjYXBlID0gL15cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS87XG5jb25zdCBpbmxpbmVDb2RlID0gL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLztcbmNvbnN0IGJyID0gL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvO1xuY29uc3QgaW5saW5lVGV4dCA9IC9eKGArfFteYF0pKD86KD89IHsyLH1cXG4pfFtcXHNcXFNdKj8oPzooPz1bXFxcXDwhXFxbYCpfXXxcXGJffCQpfFteIF0oPz0gezIsfVxcbikpKS87XG4vLyBsaXN0IG9mIHVuaWNvZGUgcHVuY3R1YXRpb24gbWFya3MsIHBsdXMgYW55IG1pc3NpbmcgY2hhcmFjdGVycyBmcm9tIENvbW1vbk1hcmsgc3BlY1xuY29uc3QgX3B1bmN0dWF0aW9uID0gJ1xcXFxwe1B9JCs8PT5gXnx+JztcbmNvbnN0IHB1bmN0dWF0aW9uID0gZWRpdCgvXigoPyFbKl9dKVtcXHNwdW5jdHVhdGlvbl0pLywgJ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBfcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4vLyBzZXF1ZW5jZXMgZW0gc2hvdWxkIHNraXAgb3ZlciBbdGl0bGVdKGxpbmspLCBgY29kZWAsIDxodG1sPlxuY29uc3QgYmxvY2tTa2lwID0gL1xcW1teW1xcXV0qP1xcXVxcKFteXFwoXFwpXSo/XFwpfGBbXmBdKj9gfDxbXjw+XSo/Pi9nO1xuY29uc3QgZW1TdHJvbmdMRGVsaW0gPSBlZGl0KC9eKD86XFwqKyg/OigoPyFcXCopW3B1bmN0XSl8W15cXHMqXSkpfF5fKyg/OigoPyFfKVtwdW5jdF0pfChbXlxcc19dKSkvLCAndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGVtU3Ryb25nUkRlbGltQXN0ID0gZWRpdCgnXlteXypdKj9fX1teXypdKj9cXFxcKlteXypdKj8oPz1fXyknIC8vIFNraXAgb3JwaGFuIGluc2lkZSBzdHJvbmdcbiAgICArICd8W14qXSsoPz1bXipdKScgLy8gQ29uc3VtZSB0byBkZWxpbVxuICAgICsgJ3woPyFcXFxcKilbcHVuY3RdKFxcXFwqKykoPz1bXFxcXHNdfCQpJyAvLyAoMSkgIyoqKiBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3xbXnB1bmN0XFxcXHNdKFxcXFwqKykoPyFcXFxcKikoPz1bcHVuY3RcXFxcc118JCknIC8vICgyKSBhKioqIywgYSoqKiBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3woPyFcXFxcKilbcHVuY3RcXFxcc10oXFxcXCorKSg/PVtecHVuY3RcXFxcc10pJyAvLyAoMykgIyoqKmEsICoqKmEgY2FuIG9ubHkgYmUgTGVmdCBEZWxpbWl0ZXJcbiAgICArICd8W1xcXFxzXShcXFxcKispKD8hXFxcXCopKD89W3B1bmN0XSknIC8vICg0KSAqKiojIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IVxcXFwqKVtwdW5jdF0oXFxcXCorKSg/IVxcXFwqKSg/PVtwdW5jdF0pJyAvLyAoNSkgIyoqKiMgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3xbXnB1bmN0XFxcXHNdKFxcXFwqKykoPz1bXnB1bmN0XFxcXHNdKScsICdndScpIC8vICg2KSBhKioqYSBjYW4gYmUgZWl0aGVyIExlZnQgb3IgUmlnaHQgRGVsaW1pdGVyXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbi8vICg2KSBOb3QgYWxsb3dlZCBmb3IgX1xuY29uc3QgZW1TdHJvbmdSRGVsaW1VbmQgPSBlZGl0KCdeW15fKl0qP1xcXFwqXFxcXCpbXl8qXSo/X1teXypdKj8oPz1cXFxcKlxcXFwqKScgLy8gU2tpcCBvcnBoYW4gaW5zaWRlIHN0cm9uZ1xuICAgICsgJ3xbXl9dKyg/PVteX10pJyAvLyBDb25zdW1lIHRvIGRlbGltXG4gICAgKyAnfCg/IV8pW3B1bmN0XShfKykoPz1bXFxcXHNdfCQpJyAvLyAoMSkgI19fXyBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3xbXnB1bmN0XFxcXHNdKF8rKSg/IV8pKD89W3B1bmN0XFxcXHNdfCQpJyAvLyAoMikgYV9fXyMsIGFfX18gY2FuIG9ubHkgYmUgYSBSaWdodCBEZWxpbWl0ZXJcbiAgICArICd8KD8hXylbcHVuY3RcXFxcc10oXyspKD89W15wdW5jdFxcXFxzXSknIC8vICgzKSAjX19fYSwgX19fYSBjYW4gb25seSBiZSBMZWZ0IERlbGltaXRlclxuICAgICsgJ3xbXFxcXHNdKF8rKSg/IV8pKD89W3B1bmN0XSknIC8vICg0KSBfX18jIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IV8pW3B1bmN0XShfKykoPyFfKSg/PVtwdW5jdF0pJywgJ2d1JykgLy8gKDUpICNfX18jIGNhbiBiZSBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbWl0ZXJcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYW55UHVuY3R1YXRpb24gPSBlZGl0KC9cXFxcKFtwdW5jdF0pLywgJ2d1JylcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYXV0b2xpbmsgPSBlZGl0KC9ePChzY2hlbWU6W15cXHNcXHgwMC1cXHgxZjw+XSp8ZW1haWwpPi8pXG4gICAgLnJlcGxhY2UoJ3NjaGVtZScsIC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LylcbiAgICAucmVwbGFjZSgnZW1haWwnLCAvW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXSsoQClbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyg/IVstX10pLylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IF9pbmxpbmVDb21tZW50ID0gZWRpdChfY29tbWVudCkucmVwbGFjZSgnKD86LS0+fCQpJywgJy0tPicpLmdldFJlZ2V4KCk7XG5jb25zdCB0YWcgPSBlZGl0KCdeY29tbWVudCdcbiAgICArICd8XjwvW2EtekEtWl1bXFxcXHc6LV0qXFxcXHMqPicgLy8gc2VsZi1jbG9zaW5nIHRhZ1xuICAgICsgJ3xePFthLXpBLVpdW1xcXFx3LV0qKD86YXR0cmlidXRlKSo/XFxcXHMqLz8+JyAvLyBvcGVuIHRhZ1xuICAgICsgJ3xePFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz4nIC8vIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGUuZy4gPD9waHAgPz5cbiAgICArICd8XjwhW2EtekEtWl0rXFxcXHNbXFxcXHNcXFxcU10qPz4nIC8vIGRlY2xhcmF0aW9uLCBlLmcuIDwhRE9DVFlQRSBodG1sPlxuICAgICsgJ3xePCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JykgLy8gQ0RBVEEgc2VjdGlvblxuICAgIC5yZXBsYWNlKCdjb21tZW50JywgX2lubGluZUNvbW1lbnQpXG4gICAgLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IF9pbmxpbmVMYWJlbCA9IC8oPzpcXFsoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSpcXF18XFxcXC58YFteYF0qYHxbXlxcW1xcXVxcXFxgXSkqPy87XG5jb25zdCBsaW5rID0gZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKFxccyooaHJlZikoPzpcXHMrKHRpdGxlKSk/XFxzKlxcKS8pXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgX2lubGluZUxhYmVsKVxuICAgIC5yZXBsYWNlKCdocmVmJywgLzwoPzpcXFxcLnxbXlxcbjw+XFxcXF0pKz58W15cXHNcXHgwMC1cXHgxZl0qLylcbiAgICAucmVwbGFjZSgndGl0bGUnLCAvXCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwnP3xbXidcXFxcXSkqJ3xcXCgoPzpcXFxcXFwpP3xbXilcXFxcXSkqXFwpLylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IHJlZmxpbmsgPSBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxbKHJlZilcXF0vKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9pbmxpbmVMYWJlbClcbiAgICAucmVwbGFjZSgncmVmJywgX2Jsb2NrTGFiZWwpXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBub2xpbmsgPSBlZGl0KC9eIT9cXFsocmVmKVxcXSg/OlxcW1xcXSk/LylcbiAgICAucmVwbGFjZSgncmVmJywgX2Jsb2NrTGFiZWwpXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCByZWZsaW5rU2VhcmNoID0gZWRpdCgncmVmbGlua3xub2xpbmsoPyFcXFxcKCknLCAnZycpXG4gICAgLnJlcGxhY2UoJ3JlZmxpbmsnLCByZWZsaW5rKVxuICAgIC5yZXBsYWNlKCdub2xpbmsnLCBub2xpbmspXG4gICAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmVOb3JtYWwgPSB7XG4gICAgX2JhY2twZWRhbDogbm9vcFRlc3QsIC8vIG9ubHkgdXNlZCBmb3IgR0ZNIHVybFxuICAgIGFueVB1bmN0dWF0aW9uLFxuICAgIGF1dG9saW5rLFxuICAgIGJsb2NrU2tpcCxcbiAgICBicixcbiAgICBjb2RlOiBpbmxpbmVDb2RlLFxuICAgIGRlbDogbm9vcFRlc3QsXG4gICAgZW1TdHJvbmdMRGVsaW0sXG4gICAgZW1TdHJvbmdSRGVsaW1Bc3QsXG4gICAgZW1TdHJvbmdSRGVsaW1VbmQsXG4gICAgZXNjYXBlLFxuICAgIGxpbmssXG4gICAgbm9saW5rLFxuICAgIHB1bmN0dWF0aW9uLFxuICAgIHJlZmxpbmssXG4gICAgcmVmbGlua1NlYXJjaCxcbiAgICB0YWcsXG4gICAgdGV4dDogaW5saW5lVGV4dCxcbiAgICB1cmw6IG5vb3BUZXN0XG59O1xuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmVQZWRhbnRpYyA9IHtcbiAgICAuLi5pbmxpbmVOb3JtYWwsXG4gICAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLylcbiAgICAgICAgLnJlcGxhY2UoJ2xhYmVsJywgX2lubGluZUxhYmVsKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICByZWZsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8pXG4gICAgICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9pbmxpbmVMYWJlbClcbiAgICAgICAgLmdldFJlZ2V4KClcbn07XG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmVHZm0gPSB7XG4gICAgLi4uaW5saW5lTm9ybWFsLFxuICAgIGVzY2FwZTogZWRpdChlc2NhcGUpLnJlcGxhY2UoJ10pJywgJ358XSknKS5nZXRSZWdleCgpLFxuICAgIHVybDogZWRpdCgvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sICdpJylcbiAgICAgICAgLnJlcGxhY2UoJ2VtYWlsJywgL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLylcbiAgICAgICAgLmdldFJlZ2V4KCksXG4gICAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl8nXCJ+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl8nXCJ+KV0rKD8hJCkpKy8sXG4gICAgZGVsOiAvXih+fj8pKD89W15cXHN+XSkoW1xcc1xcU10qP1teXFxzfl0pXFwxKD89W15+XXwkKS8sXG4gICAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS9cbn07XG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cbmNvbnN0IGlubGluZUJyZWFrcyA9IHtcbiAgICAuLi5pbmxpbmVHZm0sXG4gICAgYnI6IGVkaXQoYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gICAgdGV4dDogZWRpdChpbmxpbmVHZm0udGV4dClcbiAgICAgICAgLnJlcGxhY2UoJ1xcXFxiXycsICdcXFxcYl98IHsyLH1cXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKC9cXHsyLFxcfS9nLCAnKicpXG4gICAgICAgIC5nZXRSZWdleCgpXG59O1xuLyoqXG4gKiBleHBvcnRzXG4gKi9cbmNvbnN0IGJsb2NrID0ge1xuICAgIG5vcm1hbDogYmxvY2tOb3JtYWwsXG4gICAgZ2ZtOiBibG9ja0dmbSxcbiAgICBwZWRhbnRpYzogYmxvY2tQZWRhbnRpY1xufTtcbmNvbnN0IGlubGluZSA9IHtcbiAgICBub3JtYWw6IGlubGluZU5vcm1hbCxcbiAgICBnZm06IGlubGluZUdmbSxcbiAgICBicmVha3M6IGlubGluZUJyZWFrcyxcbiAgICBwZWRhbnRpYzogaW5saW5lUGVkYW50aWNcbn07XG5cbi8qKlxuICogQmxvY2sgTGV4ZXJcbiAqL1xuY2xhc3MgX0xleGVyIHtcbiAgICB0b2tlbnM7XG4gICAgb3B0aW9ucztcbiAgICBzdGF0ZTtcbiAgICB0b2tlbml6ZXI7XG4gICAgaW5saW5lUXVldWU7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAvLyBUb2tlbkxpc3QgY2Fubm90IGJlIGNyZWF0ZWQgaW4gb25lIGdvXG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zLmxpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgICAgIHRoaXMub3B0aW9ucy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyIHx8IG5ldyBfVG9rZW5pemVyKCk7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplcjtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy50b2tlbml6ZXIubGV4ZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLmlubGluZVF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbkxpbms6IGZhbHNlLFxuICAgICAgICAgICAgaW5SYXdCbG9jazogZmFsc2UsXG4gICAgICAgICAgICB0b3A6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVsZXMgPSB7XG4gICAgICAgICAgICBibG9jazogYmxvY2subm9ybWFsLFxuICAgICAgICAgICAgaW5saW5lOiBpbmxpbmUubm9ybWFsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2sucGVkYW50aWM7XG4gICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUucGVkYW50aWM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5nZm07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5icmVha3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuZ2ZtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5pemVyLnJ1bGVzID0gcnVsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9zZSBSdWxlc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcnVsZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgIGlubGluZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBsZXgoc3JjLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxleGVyID0gbmV3IF9MZXhlcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgbGV4SW5saW5lKHNyYywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBfTGV4ZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBsZXhlci5pbmxpbmVUb2tlbnMoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcHJvY2Vzc2luZ1xuICAgICAqL1xuICAgIGxleChzcmMpIHtcbiAgICAgICAgc3JjID0gc3JjXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJyk7XG4gICAgICAgIHRoaXMuYmxvY2tUb2tlbnMoc3JjLCB0aGlzLnRva2Vucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuaW5saW5lUXVldWVbaV07XG4gICAgICAgICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICAgIH1cbiAgICBibG9ja1Rva2VucyhzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXHQvZywgJyAgICAnKS5yZXBsYWNlKC9eICskL2dtLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXiggKikoXFx0KykvZ20sIChfLCBsZWFkaW5nLCB0YWJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmcgKyAnICAgICcucmVwZWF0KHRhYnMubGVuZ3RoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgbGV0IGxhc3RUb2tlbjtcbiAgICAgICAgbGV0IGN1dFNyYztcbiAgICAgICAgbGV0IGxhc3RQYXJhZ3JhcGhDbGlwcGVkO1xuICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9ja1xuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrLnNvbWUoKGV4dFRva2VuaXplcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbmV3bGluZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3BhY2Uoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhdy5sZW5ndGggPT09IDEgJiYgdG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHNpbmdsZSBcXG4gYXMgYSBzcGFjZXIsIGl0J3MgdGVybWluYXRpbmcgdGhlIGxhc3QgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gbW92ZSBpdCB0aGVyZSBzbyB0aGF0IHdlIGRvbid0IGdldCB1bm5lY2Vzc2FyeSBwYXJhZ3JhcGggdGFnc1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnJhdyArPSAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb2RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2RlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgLy8gQW4gaW5kZW50ZWQgY29kZSBibG9jayBjYW5ub3QgaW50ZXJydXB0IGEgcGFyYWdyYXBoLlxuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmZW5jZXNcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoZWFkaW5nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5oZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhyXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ocihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBibG9ja3F1b3RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ibG9ja3F1b3RlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxpc3RcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpc3Qoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaHRtbFxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHRtbChzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWZcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlZihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b2tlbi50aXRsZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRhYmxlIChnZm0pXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWJsZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaGVhZGluZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGhlYWRpbmcoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdG9wLWxldmVsIHBhcmFncmFwaFxuICAgICAgICAgICAgLy8gcHJldmVudCBwYXJhZ3JhcGggY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICAgICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0QmxvY2suZm9yRWFjaCgoZ2V0U3RhcnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09ICdudW1iZXInICYmIHRlbXBTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5wYXJhZ3JhcGgoY3V0U3JjKSkpIHtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyYWdyYXBoQ2xpcHBlZCAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RQYXJhZ3JhcGhDbGlwcGVkID0gKGN1dFNyYy5sZW5ndGggIT09IHNyYy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50ZXh0KHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIGlubGluZShzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUucHVzaCh7IHNyYywgdG9rZW5zIH0pO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgaW5saW5lVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICAgICAgbGV0IHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYztcbiAgICAgICAgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcbiAgICAgICAgbGV0IG1hc2tlZFNyYyA9IHNyYztcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBsZXQga2VlcFByZXZDaGFyLCBwcmV2Q2hhcjtcbiAgICAgICAgLy8gTWFzayBvdXQgcmVmbGlua3NcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zLmxpbmtzKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IE9iamVjdC5rZXlzKHRoaXMudG9rZW5zLmxpbmtzKTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyAnYScucmVwZWF0KG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmxhc3RJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFzayBvdXQgb3RoZXIgYmxvY2tzXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5sYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hc2sgb3V0IGVzY2FwZWQgY2hhcmFjdGVyc1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICcrKycgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLmxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgaWYgKCFrZWVwUHJldkNoYXIpIHtcbiAgICAgICAgICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2VlcFByZXZDaGFyID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBleHRlbnNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmVcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmUuc29tZSgoZXh0VG9rZW5pemVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2NhcGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVzY2FwZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0YWdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGlua1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnJlZmxpbmsoc3JjLCB0aGlzLnRva2Vucy5saW5rcykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbSAmIHN0cm9uZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29kZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZXNwYW4oc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJyKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlbCAoZ2ZtKVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVsKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGF1dG9saW5rXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5hdXRvbGluayhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1cmwgKGdmbSlcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5pbkxpbmsgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudXJsKHNyYykpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGlubGluZVRleHQgY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICAgICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBTcmMgPSBzcmMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXBTdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZS5mb3JFYWNoKChnZXRTdGFydEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdGFydCA9IGdldFN0YXJ0SW5kZXguY2FsbCh7IGxleGVyOiB0aGlzIH0sIHRlbXBTcmMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydEluZGV4LCB0ZW1wU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaW5saW5lVGV4dChjdXRTcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ucmF3LnNsaWNlKC0xKSAhPT0gJ18nKSB7IC8vIFRyYWNrIHByZXZDaGFyIGJlZm9yZSBzdHJpbmcgb2YgX19fXyBzdGFydGVkXG4gICAgICAgICAgICAgICAgICAgIHByZXZDaGFyID0gdG9rZW4ucmF3LnNsaWNlKC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2VlcFByZXZDaGFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuY2xhc3MgX1JlbmRlcmVyIHtcbiAgICBvcHRpb25zO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgfVxuICAgIGNvZGUoY29kZSwgaW5mb3N0cmluZywgZXNjYXBlZCkge1xuICAgICAgICBjb25zdCBsYW5nID0gKGluZm9zdHJpbmcgfHwgJycpLm1hdGNoKC9eXFxTKi8pPy5bMF07XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcbiQvLCAnJykgKyAnXFxuJztcbiAgICAgICAgaWYgKCFsYW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgICAgICAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlJDEoY29kZSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtJ1xuICAgICAgICAgICAgKyBlc2NhcGUkMShsYW5nKVxuICAgICAgICAgICAgKyAnXCI+J1xuICAgICAgICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUkMShjb2RlLCB0cnVlKSlcbiAgICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH1cbiAgICBibG9ja3F1b3RlKHF1b3RlKSB7XG4gICAgICAgIHJldHVybiBgPGJsb2NrcXVvdGU+XFxuJHtxdW90ZX08L2Jsb2NrcXVvdGU+XFxuYDtcbiAgICB9XG4gICAgaHRtbChodG1sLCBibG9jaykge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgaGVhZGluZyh0ZXh0LCBsZXZlbCwgcmF3KSB7XG4gICAgICAgIC8vIGlnbm9yZSBJRHNcbiAgICAgICAgcmV0dXJuIGA8aCR7bGV2ZWx9PiR7dGV4dH08L2gke2xldmVsfT5cXG5gO1xuICAgIH1cbiAgICBocigpIHtcbiAgICAgICAgcmV0dXJuICc8aHI+XFxuJztcbiAgICB9XG4gICAgbGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCkge1xuICAgICAgICBjb25zdCB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnO1xuICAgICAgICBjb25zdCBzdGFydGF0dCA9IChvcmRlcmVkICYmIHN0YXJ0ICE9PSAxKSA/ICgnIHN0YXJ0PVwiJyArIHN0YXJ0ICsgJ1wiJykgOiAnJztcbiAgICAgICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydGF0dCArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgICB9XG4gICAgbGlzdGl0ZW0odGV4dCwgdGFzaywgY2hlY2tlZCkge1xuICAgICAgICByZXR1cm4gYDxsaT4ke3RleHR9PC9saT5cXG5gO1xuICAgIH1cbiAgICBjaGVja2JveChjaGVja2VkKSB7XG4gICAgICAgIHJldHVybiAnPGlucHV0ICdcbiAgICAgICAgICAgICsgKGNoZWNrZWQgPyAnY2hlY2tlZD1cIlwiICcgOiAnJylcbiAgICAgICAgICAgICsgJ2Rpc2FibGVkPVwiXCIgdHlwZT1cImNoZWNrYm94XCI+JztcbiAgICB9XG4gICAgcGFyYWdyYXBoKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8cD4ke3RleHR9PC9wPlxcbmA7XG4gICAgfVxuICAgIHRhYmxlKGhlYWRlciwgYm9keSkge1xuICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgIGJvZHkgPSBgPHRib2R5PiR7Ym9keX08L3Rib2R5PmA7XG4gICAgICAgIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICAgICAgICAgICsgJzx0aGVhZD5cXG4nXG4gICAgICAgICAgICArIGhlYWRlclxuICAgICAgICAgICAgKyAnPC90aGVhZD5cXG4nXG4gICAgICAgICAgICArIGJvZHlcbiAgICAgICAgICAgICsgJzwvdGFibGU+XFxuJztcbiAgICB9XG4gICAgdGFibGVyb3coY29udGVudCkge1xuICAgICAgICByZXR1cm4gYDx0cj5cXG4ke2NvbnRlbnR9PC90cj5cXG5gO1xuICAgIH1cbiAgICB0YWJsZWNlbGwoY29udGVudCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgICAgICBjb25zdCB0YWcgPSBmbGFncy5hbGlnblxuICAgICAgICAgICAgPyBgPCR7dHlwZX0gYWxpZ249XCIke2ZsYWdzLmFsaWdufVwiPmBcbiAgICAgICAgICAgIDogYDwke3R5cGV9PmA7XG4gICAgICAgIHJldHVybiB0YWcgKyBjb250ZW50ICsgYDwvJHt0eXBlfT5cXG5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzcGFuIGxldmVsIHJlbmRlcmVyXG4gICAgICovXG4gICAgc3Ryb25nKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8c3Ryb25nPiR7dGV4dH08L3N0cm9uZz5gO1xuICAgIH1cbiAgICBlbSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBgPGVtPiR7dGV4dH08L2VtPmA7XG4gICAgfVxuICAgIGNvZGVzcGFuKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8Y29kZT4ke3RleHR9PC9jb2RlPmA7XG4gICAgfVxuICAgIGJyKCkge1xuICAgICAgICByZXR1cm4gJzxicj4nO1xuICAgIH1cbiAgICBkZWwodGV4dCkge1xuICAgICAgICByZXR1cm4gYDxkZWw+JHt0ZXh0fTwvZGVsPmA7XG4gICAgfVxuICAgIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgY29uc3QgY2xlYW5IcmVmID0gY2xlYW5VcmwoaHJlZik7XG4gICAgICAgIGlmIChjbGVhbkhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSBjbGVhbkhyZWY7XG4gICAgICAgIGxldCBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNsZWFuSHJlZiA9IGNsZWFuVXJsKGhyZWYpO1xuICAgICAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBocmVmID0gY2xlYW5IcmVmO1xuICAgICAgICBsZXQgb3V0ID0gYDxpbWcgc3JjPVwiJHtocmVmfVwiIGFsdD1cIiR7dGV4dH1cImA7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgb3V0ICs9IGAgdGl0bGU9XCIke3RpdGxlfVwiYDtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJz4nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB0ZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIFRleHRSZW5kZXJlclxuICogcmV0dXJucyBvbmx5IHRoZSB0ZXh0dWFsIHBhcnQgb2YgdGhlIHRva2VuXG4gKi9cbmNsYXNzIF9UZXh0UmVuZGVyZXIge1xuICAgIC8vIG5vIG5lZWQgZm9yIGJsb2NrIGxldmVsIHJlbmRlcmVyc1xuICAgIHN0cm9uZyh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBlbSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb2Rlc3Bhbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBkZWwodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgaHRtbCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB0ZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgYnIoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5jbGFzcyBfUGFyc2VyIHtcbiAgICBvcHRpb25zO1xuICAgIHJlbmRlcmVyO1xuICAgIHRleHRSZW5kZXJlcjtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IF9SZW5kZXJlcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMudGV4dFJlbmRlcmVyID0gbmV3IF9UZXh0UmVuZGVyZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9QYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VJbmxpbmUodG9rZW5zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBfUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIExvb3BcbiAgICAgKi9cbiAgICBwYXJzZSh0b2tlbnMsIHRvcCA9IHRydWUpIHtcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW2dlbmVyaWNUb2tlbi50eXBlXS5jYWxsKHsgcGFyc2VyOiB0aGlzIH0sIGdlbmVyaWNUb2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHJldCAhPT0gZmFsc2UgfHwgIVsnc3BhY2UnLCAnaHInLCAnaGVhZGluZycsICdjb2RlJywgJ3RhYmxlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcsICdodG1sJywgJ3BhcmFncmFwaCcsICd0ZXh0J10uaW5jbHVkZXMoZ2VuZXJpY1Rva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaHInOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaGVhZGluZyh0aGlzLnBhcnNlSW5saW5lKGhlYWRpbmdUb2tlbi50b2tlbnMpLCBoZWFkaW5nVG9rZW4uZGVwdGgsIHVuZXNjYXBlKHRoaXMucGFyc2VJbmxpbmUoaGVhZGluZ1Rva2VuLnRva2VucywgdGhpcy50ZXh0UmVuZGVyZXIpKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjb2RlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZShjb2RlVG9rZW4udGV4dCwgY29kZVRva2VuLmxhbmcsICEhY29kZVRva2VuLmVzY2FwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndGFibGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhlYWRlciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAvLyBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWJsZVRva2VuLmhlYWRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHRhYmxlVG9rZW4uaGVhZGVyW2pdLnRva2VucyksIHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGFibGVUb2tlbi5hbGlnbltqXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWJsZVRva2VuLnJvd3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRhYmxlVG9rZW4ucm93c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcm93Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHJvd1trXS50b2tlbnMpLCB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0YWJsZVRva2VuLmFsaWduW2tdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdibG9ja3F1b3RlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja3F1b3RlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMucGFyc2UoYmxvY2txdW90ZVRva2VuLnRva2Vucyk7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJlZCA9IGxpc3RUb2tlbi5vcmRlcmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGxpc3RUb2tlbi5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9vc2UgPSBsaXN0VG9rZW4ubG9vc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBib2R5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGlzdFRva2VuLml0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbGlzdFRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGl0ZW0uY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBpdGVtLnRhc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbUJvZHkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IHRoaXMucmVuZGVyZXIuY2hlY2tib3goISFjaGVja2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0udG9rZW5zICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vucy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2hlY2tib3ggKyAnICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQm9keSArPSBjaGVja2JveCArICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtQm9keSArPSB0aGlzLnBhcnNlKGl0ZW0udG9rZW5zLCBsb29zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oaXRlbUJvZHksIHRhc2ssICEhY2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdodG1sJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBodG1sVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHRtbChodG1sVG9rZW4udGV4dCwgaHRtbFRva2VuLmJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VJbmxpbmUocGFyYWdyYXBoVG9rZW4udG9rZW5zKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGxldCBib2R5ID0gdGV4dFRva2VuLnRva2VucyA/IHRoaXMucGFyc2VJbmxpbmUodGV4dFRva2VuLnRva2VucykgOiB0ZXh0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgKyAxIDwgdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbaSArIDFdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFRva2VuID0gdG9rZW5zWysraV07XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ICs9ICdcXG4nICsgKHRleHRUb2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRleHRUb2tlbi50b2tlbnMpIDogdGV4dFRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0b3AgPyB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaChib2R5KSA6IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBJbmxpbmUgVG9rZW5zXG4gICAgICovXG4gICAgcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlciA9IHJlbmRlcmVyIHx8IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgLy8gUnVuIGFueSByZW5kZXJlciBleHRlbnNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXS5jYWxsKHsgcGFyc2VyOiB0aGlzIH0sIHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydlc2NhcGUnLCAnaHRtbCcsICdsaW5rJywgJ2ltYWdlJywgJ3N0cm9uZycsICdlbScsICdjb2Rlc3BhbicsICdicicsICdkZWwnLCAndGV4dCddLmluY2x1ZGVzKHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VzY2FwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQoZXNjYXBlVG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdodG1sJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaHRtbCh0YWdUb2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2xpbmsnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIubGluayhsaW5rVG9rZW4uaHJlZiwgbGlua1Rva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKGxpbmtUb2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdpbWFnZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaW1hZ2UoaW1hZ2VUb2tlbi5ocmVmLCBpbWFnZVRva2VuLnRpdGxlLCBpbWFnZVRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnc3Ryb25nJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJvbmdUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRoaXMucGFyc2VJbmxpbmUoc3Ryb25nVG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZW0nOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmVtKHRoaXMucGFyc2VJbmxpbmUoZW1Ub2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjb2Rlc3Bhbic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZXNwYW5Ub2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuY29kZXNwYW4oY29kZXNwYW5Ub2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2JyJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuYnIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2RlbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmRlbCh0aGlzLnBhcnNlSW5saW5lKGRlbFRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0ZXh0VG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn1cblxuY2xhc3MgX0hvb2tzIHtcbiAgICBvcHRpb25zO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgfVxuICAgIHN0YXRpYyBwYXNzVGhyb3VnaEhvb2tzID0gbmV3IFNldChbXG4gICAgICAgICdwcmVwcm9jZXNzJyxcbiAgICAgICAgJ3Bvc3Rwcm9jZXNzJyxcbiAgICAgICAgJ3Byb2Nlc3NBbGxUb2tlbnMnXG4gICAgXSk7XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBtYXJrZG93biBiZWZvcmUgbWFya2VkXG4gICAgICovXG4gICAgcHJlcHJvY2VzcyhtYXJrZG93bikge1xuICAgICAgICByZXR1cm4gbWFya2Rvd247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgSFRNTCBhZnRlciBtYXJrZWQgaXMgZmluaXNoZWRcbiAgICAgKi9cbiAgICBwb3N0cHJvY2VzcyhodG1sKSB7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFsbCB0b2tlbnMgYmVmb3JlIHdhbGsgdG9rZW5zXG4gICAgICovXG4gICAgcHJvY2Vzc0FsbFRva2Vucyh0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5cbmNsYXNzIE1hcmtlZCB7XG4gICAgZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbiAgICBvcHRpb25zID0gdGhpcy5zZXRPcHRpb25zO1xuICAgIHBhcnNlID0gdGhpcy4jcGFyc2VNYXJrZG93bihfTGV4ZXIubGV4LCBfUGFyc2VyLnBhcnNlKTtcbiAgICBwYXJzZUlubGluZSA9IHRoaXMuI3BhcnNlTWFya2Rvd24oX0xleGVyLmxleElubGluZSwgX1BhcnNlci5wYXJzZUlubGluZSk7XG4gICAgUGFyc2VyID0gX1BhcnNlcjtcbiAgICBSZW5kZXJlciA9IF9SZW5kZXJlcjtcbiAgICBUZXh0UmVuZGVyZXIgPSBfVGV4dFJlbmRlcmVyO1xuICAgIExleGVyID0gX0xleGVyO1xuICAgIFRva2VuaXplciA9IF9Ub2tlbml6ZXI7XG4gICAgSG9va3MgPSBfSG9va3M7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICB0aGlzLnVzZSguLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICAgICAqL1xuICAgIHdhbGtUb2tlbnModG9rZW5zLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KGNhbGxiYWNrLmNhbGwodGhpcywgdG9rZW4pKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RhYmxlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZVRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiB0YWJsZVRva2VuLmhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMoY2VsbC50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGVUb2tlbi5yb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMoY2VsbC50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2xpc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhsaXN0VG9rZW4uaXRlbXMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyaWNUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5leHRlbnNpb25zPy5jaGlsZFRva2Vucz8uW2dlbmVyaWNUb2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zW2dlbmVyaWNUb2tlbi50eXBlXS5mb3JFYWNoKChjaGlsZFRva2VucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IGdlbmVyaWNUb2tlbltjaGlsZFRva2Vuc10uZmxhdChJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnModG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZ2VuZXJpY1Rva2VuLnRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMoZ2VuZXJpY1Rva2VuLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICB1c2UoLi4uYXJncykge1xuICAgICAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5kZWZhdWx0cy5leHRlbnNpb25zIHx8IHsgcmVuZGVyZXJzOiB7fSwgY2hpbGRUb2tlbnM6IHt9IH07XG4gICAgICAgIGFyZ3MuZm9yRWFjaCgocGFjaykgPT4ge1xuICAgICAgICAgICAgLy8gY29weSBvcHRpb25zIHRvIG5ldyBvYmplY3RcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSB7IC4uLnBhY2sgfTtcbiAgICAgICAgICAgIC8vIHNldCBhc3luYyB0byB0cnVlIGlmIGl0IHdhcyBzZXQgdG8gdHJ1ZSBiZWZvcmVcbiAgICAgICAgICAgIG9wdHMuYXN5bmMgPSB0aGlzLmRlZmF1bHRzLmFzeW5jIHx8IG9wdHMuYXN5bmMgfHwgZmFsc2U7XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFwiYWRkb25cIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBwYWNrLmV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXh0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0ZW5zaW9uIG5hbWUgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3JlbmRlcmVyJyBpbiBleHQpIHsgLy8gUmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlJlbmRlcmVyID0gZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgZXh0ZW5zaW9uIHdpdGggZnVuYyB0byBydW4gbmV3IGV4dGVuc2lvbiBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IGV4dC5yZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBleHQucmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0b2tlbml6ZXInIGluIGV4dCkgeyAvLyBUb2tlbml6ZXIgRXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleHQubGV2ZWwgfHwgKGV4dC5sZXZlbCAhPT0gJ2Jsb2NrJyAmJiBleHQubGV2ZWwgIT09ICdpbmxpbmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4dGVuc2lvbiBsZXZlbCBtdXN0IGJlICdibG9jaycgb3IgJ2lubGluZSdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRMZXZlbCA9IGV4dGVuc2lvbnNbZXh0LmxldmVsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dExldmVsLnVuc2hpZnQoZXh0LnRva2VuaXplcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zW2V4dC5sZXZlbF0gPSBbZXh0LnRva2VuaXplcl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0LnN0YXJ0KSB7IC8vIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciBzdGFydCBvZiB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHQubGV2ZWwgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnMuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydEJsb2NrLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRCbG9jayA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4dC5sZXZlbCA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZSA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgnY2hpbGRUb2tlbnMnIGluIGV4dCAmJiBleHQuY2hpbGRUb2tlbnMpIHsgLy8gQ2hpbGQgdG9rZW5zIHRvIGJlIHZpc2l0ZWQgYnkgd2Fsa1Rva2Vuc1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1tleHQubmFtZV0gPSBleHQuY2hpbGRUb2tlbnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcHRzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBcIm92ZXJ3cml0ZVwiIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2sucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZGVmYXVsdHMucmVuZGVyZXIgfHwgbmV3IF9SZW5kZXJlcih0aGlzLmRlZmF1bHRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay5yZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwcm9wIGluIHJlbmRlcmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZW5kZXJlciAnJHtwcm9wfScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgb3B0aW9ucyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJQcm9wID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJGdW5jID0gcGFjay5yZW5kZXJlcltyZW5kZXJlclByb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2UmVuZGVyZXIgPSByZW5kZXJlcltyZW5kZXJlclByb3BdO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHJlbmRlcmVyIHdpdGggZnVuYyB0byBydW4gZXh0ZW5zaW9uLCBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyW3JlbmRlcmVyUHJvcF0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IHJlbmRlcmVyRnVuYy5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbml6ZXIgPSB0aGlzLmRlZmF1bHRzLnRva2VuaXplciB8fCBuZXcgX1Rva2VuaXplcih0aGlzLmRlZmF1bHRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocHJvcCBpbiB0b2tlbml6ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRva2VuaXplciAnJHtwcm9wfScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoWydvcHRpb25zJywgJ3J1bGVzJywgJ2xleGVyJ10uaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBvcHRpb25zLCBydWxlcywgYW5kIGxleGVyIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuaXplclByb3AgPSBwcm9wO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbml6ZXJGdW5jID0gcGFjay50b2tlbml6ZXJbdG9rZW5pemVyUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZUb2tlbml6ZXIgPSB0b2tlbml6ZXJbdG9rZW5pemVyUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdG9rZW5pemVyIHdpdGggZnVuYyB0byBydW4gZXh0ZW5zaW9uLCBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IHR5cGUgdG9rZW5pemVyIGZ1bmN0aW9uIGR5bmFtaWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIHRva2VuaXplclt0b2tlbml6ZXJQcm9wXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gdG9rZW5pemVyRnVuYy5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwcmV2VG9rZW5pemVyLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vID09LS0gUGFyc2UgSG9va3MgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay5ob29rcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvb2tzID0gdGhpcy5kZWZhdWx0cy5ob29rcyB8fCBuZXcgX0hvb2tzKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHBhY2suaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocHJvcCBpbiBob29rcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaG9vayAnJHtwcm9wfScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgb3B0aW9ucyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3NQcm9wID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3NGdW5jID0gcGFjay5ob29rc1tob29rc1Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2SG9vayA9IGhvb2tzW2hvb2tzUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfSG9va3MucGFzc1Rocm91Z2hIb29rcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IHR5cGUgaG9vayBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3NbaG9va3NQcm9wXSA9IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpKS50aGVuKHJldCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SG9vay5jYWxsKGhvb2tzLCByZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IHR5cGUgaG9vayBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3NbaG9va3NQcm9wXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IGhvb2tzRnVuYy5hcHBseShob29rcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldkhvb2suYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLmhvb2tzID0gaG9va3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFdhbGtUb2tlbnMgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2Fsa1Rva2VucyA9IHRoaXMuZGVmYXVsdHMud2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrV2Fsa3Rva2VucyA9IHBhY2sud2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICBvcHRzLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYWNrV2Fsa3Rva2Vucy5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHdhbGtUb2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9wdHMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRzID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcHQgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxleGVyKHNyYywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX0xleGVyLmxleChzcmMsIG9wdGlvbnMgPz8gdGhpcy5kZWZhdWx0cyk7XG4gICAgfVxuICAgIHBhcnNlcih0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9QYXJzZXIucGFyc2UodG9rZW5zLCBvcHRpb25zID8/IHRoaXMuZGVmYXVsdHMpO1xuICAgIH1cbiAgICAjcGFyc2VNYXJrZG93bihsZXhlciwgcGFyc2VyKSB7XG4gICAgICAgIHJldHVybiAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcmlnT3B0ID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBvcHQgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9yaWdPcHQgfTtcbiAgICAgICAgICAgIC8vIFNob3cgd2FybmluZyBpZiBhbiBleHRlbnNpb24gc2V0IGFzeW5jIHRvIHRydWUgYnV0IHRoZSBwYXJzZSB3YXMgY2FsbGVkIHdpdGggYXN5bmM6IGZhbHNlXG4gICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5hc3luYyA9PT0gdHJ1ZSAmJiBvcmlnT3B0LmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0LnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ21hcmtlZCgpOiBUaGUgYXN5bmMgb3B0aW9uIHdhcyBzZXQgdG8gdHJ1ZSBieSBhbiBleHRlbnNpb24uIFRoZSBhc3luYzogZmFsc2Ugb3B0aW9uIHNlbnQgdG8gcGFyc2Ugd2lsbCBiZSBpZ25vcmVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGhyb3dFcnJvciA9IHRoaXMuI29uRXJyb3IoISFvcHQuc2lsZW50LCAhIW9wdC5hc3luYyk7XG4gICAgICAgICAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSAnXG4gICAgICAgICAgICAgICAgICAgICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyYykgKyAnLCBzdHJpbmcgZXhwZWN0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgb3B0Lmhvb2tzLm9wdGlvbnMgPSBvcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0LmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvcHQuaG9va3MgPyBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpIDogc3JjKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihzcmMgPT4gbGV4ZXIoc3JjLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0b2tlbnMgPT4gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByb2Nlc3NBbGxUb2tlbnModG9rZW5zKSA6IHRva2VucylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW5zID0+IG9wdC53YWxrVG9rZW5zID8gUHJvbWlzZS5hbGwodGhpcy53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpKS50aGVuKCgpID0+IHRva2VucykgOiB0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRva2VucyA9PiBwYXJzZXIodG9rZW5zLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihodG1sID0+IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKSA6IGh0bWwpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aHJvd0Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5zID0gbGV4ZXIoc3JjLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gb3B0Lmhvb2tzLnByb2Nlc3NBbGxUb2tlbnModG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGh0bWwgPSBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA9IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAjb25FcnJvcihzaWxlbnQsIGFzeW5jKSB7XG4gICAgICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgICAgICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuICAgICAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICc8cD5BbiBlcnJvciBvY2N1cnJlZDo8L3A+PHByZT4nXG4gICAgICAgICAgICAgICAgICAgICsgZXNjYXBlJDEoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICsgJzwvcHJlPic7XG4gICAgICAgICAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jb25zdCBtYXJrZWRJbnN0YW5jZSA9IG5ldyBNYXJrZWQoKTtcbmZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCkge1xuICAgIHJldHVybiBtYXJrZWRJbnN0YW5jZS5wYXJzZShzcmMsIG9wdCk7XG59XG4vKipcbiAqIFNldHMgdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyBIYXNoIG9mIG9wdGlvbnNcbiAqL1xubWFya2VkLm9wdGlvbnMgPVxuICAgIG1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgbWFya2VkSW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgbWFya2VkLmRlZmF1bHRzID0gbWFya2VkSW5zdGFuY2UuZGVmYXVsdHM7XG4gICAgICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgICAgIHJldHVybiBtYXJrZWQ7XG4gICAgfTtcbi8qKlxuICogR2V0cyB0aGUgb3JpZ2luYWwgbWFya2VkIGRlZmF1bHQgb3B0aW9ucy5cbiAqL1xubWFya2VkLmdldERlZmF1bHRzID0gX2dldERlZmF1bHRzO1xubWFya2VkLmRlZmF1bHRzID0gX2RlZmF1bHRzO1xuLyoqXG4gKiBVc2UgRXh0ZW5zaW9uXG4gKi9cbm1hcmtlZC51c2UgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIG1hcmtlZEluc3RhbmNlLnVzZSguLi5hcmdzKTtcbiAgICBtYXJrZWQuZGVmYXVsdHMgPSBtYXJrZWRJbnN0YW5jZS5kZWZhdWx0cztcbiAgICBjaGFuZ2VEZWZhdWx0cyhtYXJrZWQuZGVmYXVsdHMpO1xuICAgIHJldHVybiBtYXJrZWQ7XG59O1xuLyoqXG4gKiBSdW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IHRva2VuXG4gKi9cbm1hcmtlZC53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VucywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbWFya2VkSW5zdGFuY2Uud2Fsa1Rva2Vucyh0b2tlbnMsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIENvbXBpbGVzIG1hcmtkb3duIHRvIEhUTUwgd2l0aG91dCBlbmNsb3NpbmcgYHBgIHRhZy5cbiAqXG4gKiBAcGFyYW0gc3JjIFN0cmluZyBvZiBtYXJrZG93biBzb3VyY2UgdG8gYmUgY29tcGlsZWRcbiAqIEBwYXJhbSBvcHRpb25zIEhhc2ggb2Ygb3B0aW9uc1xuICogQHJldHVybiBTdHJpbmcgb2YgY29tcGlsZWQgSFRNTFxuICovXG5tYXJrZWQucGFyc2VJbmxpbmUgPSBtYXJrZWRJbnN0YW5jZS5wYXJzZUlubGluZTtcbi8qKlxuICogRXhwb3NlXG4gKi9cbm1hcmtlZC5QYXJzZXIgPSBfUGFyc2VyO1xubWFya2VkLnBhcnNlciA9IF9QYXJzZXIucGFyc2U7XG5tYXJrZWQuUmVuZGVyZXIgPSBfUmVuZGVyZXI7XG5tYXJrZWQuVGV4dFJlbmRlcmVyID0gX1RleHRSZW5kZXJlcjtcbm1hcmtlZC5MZXhlciA9IF9MZXhlcjtcbm1hcmtlZC5sZXhlciA9IF9MZXhlci5sZXg7XG5tYXJrZWQuVG9rZW5pemVyID0gX1Rva2VuaXplcjtcbm1hcmtlZC5Ib29rcyA9IF9Ib29rcztcbm1hcmtlZC5wYXJzZSA9IG1hcmtlZDtcbmNvbnN0IG9wdGlvbnMgPSBtYXJrZWQub3B0aW9ucztcbmNvbnN0IHNldE9wdGlvbnMgPSBtYXJrZWQuc2V0T3B0aW9ucztcbmNvbnN0IHVzZSA9IG1hcmtlZC51c2U7XG5jb25zdCB3YWxrVG9rZW5zID0gbWFya2VkLndhbGtUb2tlbnM7XG5jb25zdCBwYXJzZUlubGluZSA9IG1hcmtlZC5wYXJzZUlubGluZTtcbmNvbnN0IHBhcnNlID0gbWFya2VkO1xuY29uc3QgcGFyc2VyID0gX1BhcnNlci5wYXJzZTtcbmNvbnN0IGxleGVyID0gX0xleGVyLmxleDtcblxuZXhwb3J0IHsgX0hvb2tzIGFzIEhvb2tzLCBfTGV4ZXIgYXMgTGV4ZXIsIE1hcmtlZCwgX1BhcnNlciBhcyBQYXJzZXIsIF9SZW5kZXJlciBhcyBSZW5kZXJlciwgX1RleHRSZW5kZXJlciBhcyBUZXh0UmVuZGVyZXIsIF9Ub2tlbml6ZXIgYXMgVG9rZW5pemVyLCBfZGVmYXVsdHMgYXMgZGVmYXVsdHMsIF9nZXREZWZhdWx0cyBhcyBnZXREZWZhdWx0cywgbGV4ZXIsIG1hcmtlZCwgb3B0aW9ucywgcGFyc2UsIHBhcnNlSW5saW5lLCBwYXJzZXIsIHNldE9wdGlvbnMsIHVzZSwgd2Fsa1Rva2VucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFya2VkLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZ2V0RGVmYXVsdHMiLCJhc3luYyIsImJyZWFrcyIsImV4dGVuc2lvbnMiLCJnZm0iLCJob29rcyIsInBlZGFudGljIiwicmVuZGVyZXIiLCJzaWxlbnQiLCJ0b2tlbml6ZXIiLCJ3YWxrVG9rZW5zIiwiX2RlZmF1bHRzIiwiY2hhbmdlRGVmYXVsdHMiLCJuZXdEZWZhdWx0cyIsImVzY2FwZVRlc3QiLCJlc2NhcGVSZXBsYWNlIiwiUmVnRXhwIiwic291cmNlIiwiZXNjYXBlVGVzdE5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZU5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZW1lbnRzIiwiZ2V0RXNjYXBlUmVwbGFjZW1lbnQiLCJjaCIsImVzY2FwZSQxIiwiaHRtbCIsImVuY29kZSIsInRlc3QiLCJyZXBsYWNlIiwidW5lc2NhcGVUZXN0IiwidW5lc2NhcGUiLCJfIiwibiIsInRvTG93ZXJDYXNlIiwiY2hhckF0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJjYXJldCIsImVkaXQiLCJyZWdleCIsIm9wdCIsIm9iaiIsIm5hbWUiLCJ2YWwiLCJ2YWxTb3VyY2UiLCJnZXRSZWdleCIsImNsZWFuVXJsIiwiaHJlZiIsImVuY29kZVVSSSIsImUiLCJub29wVGVzdCIsImV4ZWMiLCJzcGxpdENlbGxzIiwidGFibGVSb3ciLCJjb3VudCIsInJvdyIsIm1hdGNoIiwib2Zmc2V0Iiwic3RyIiwiZXNjYXBlZCIsImN1cnIiLCJjZWxscyIsInNwbGl0IiwiaSIsInRyaW0iLCJzaGlmdCIsImxlbmd0aCIsInBvcCIsInNwbGljZSIsInB1c2giLCJydHJpbSIsImMiLCJpbnZlcnQiLCJsIiwic3VmZkxlbiIsImN1cnJDaGFyIiwic2xpY2UiLCJmaW5kQ2xvc2luZ0JyYWNrZXQiLCJiIiwiaW5kZXhPZiIsImxldmVsIiwib3V0cHV0TGluayIsImNhcCIsImxpbmsiLCJyYXciLCJsZXhlciIsInRpdGxlIiwidGV4dCIsInN0YXRlIiwiaW5MaW5rIiwidG9rZW4iLCJ0eXBlIiwidG9rZW5zIiwiaW5saW5lVG9rZW5zIiwiaW5kZW50Q29kZUNvbXBlbnNhdGlvbiIsIm1hdGNoSW5kZW50VG9Db2RlIiwiaW5kZW50VG9Db2RlIiwibWFwIiwibm9kZSIsIm1hdGNoSW5kZW50SW5Ob2RlIiwiaW5kZW50SW5Ob2RlIiwiam9pbiIsIl9Ub2tlbml6ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJzcGFjZSIsInNyYyIsInJ1bGVzIiwiYmxvY2siLCJuZXdsaW5lIiwiY29kZSIsImNvZGVCbG9ja1N0eWxlIiwiZmVuY2VzIiwibGFuZyIsImlubGluZSIsImFueVB1bmN0dWF0aW9uIiwiaGVhZGluZyIsInRyaW1tZWQiLCJkZXB0aCIsImhyIiwiYmxvY2txdW90ZSIsInRvcCIsImJsb2NrVG9rZW5zIiwibGlzdCIsImJ1bGwiLCJpc29yZGVyZWQiLCJvcmRlcmVkIiwic3RhcnQiLCJsb29zZSIsIml0ZW1zIiwiaXRlbVJlZ2V4IiwiaXRlbUNvbnRlbnRzIiwiZW5kc1dpdGhCbGFua0xpbmUiLCJlbmRFYXJseSIsImxpbmUiLCJ0IiwicmVwZWF0IiwibmV4dExpbmUiLCJpbmRlbnQiLCJ0cmltU3RhcnQiLCJzZWFyY2giLCJibGFua0xpbmUiLCJuZXh0QnVsbGV0UmVnZXgiLCJNYXRoIiwibWluIiwiaHJSZWdleCIsImZlbmNlc0JlZ2luUmVnZXgiLCJoZWFkaW5nQmVnaW5SZWdleCIsInJhd0xpbmUiLCJpc3Rhc2siLCJpc2NoZWNrZWQiLCJ0YXNrIiwiY2hlY2tlZCIsInRyaW1FbmQiLCJzcGFjZXJzIiwiZmlsdGVyIiwiaGFzTXVsdGlwbGVMaW5lQnJlYWtzIiwic29tZSIsInByZSIsImRlZiIsInRhZyIsInRhYmxlIiwiaGVhZGVycyIsImFsaWducyIsInJvd3MiLCJpdGVtIiwiaGVhZGVyIiwiYWxpZ24iLCJjZWxsIiwibGhlYWRpbmciLCJwYXJhZ3JhcGgiLCJlc2NhcGUiLCJpblJhd0Jsb2NrIiwidHJpbW1lZFVybCIsInJ0cmltU2xhc2giLCJsYXN0UGFyZW5JbmRleCIsImxpbmtMZW4iLCJyZWZsaW5rIiwibGlua3MiLCJub2xpbmsiLCJsaW5rU3RyaW5nIiwiZW1TdHJvbmciLCJtYXNrZWRTcmMiLCJwcmV2Q2hhciIsImVtU3Ryb25nTERlbGltIiwibmV4dENoYXIiLCJwdW5jdHVhdGlvbiIsImxMZW5ndGgiLCJyRGVsaW0iLCJyTGVuZ3RoIiwiZGVsaW1Ub3RhbCIsIm1pZERlbGltVG90YWwiLCJlbmRSZWciLCJlbVN0cm9uZ1JEZWxpbUFzdCIsImVtU3Ryb25nUkRlbGltVW5kIiwibGFzdEluZGV4IiwibGFzdENoYXJMZW5ndGgiLCJpbmRleCIsImNvZGVzcGFuIiwiaGFzTm9uU3BhY2VDaGFycyIsImhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzIiwiYnIiLCJkZWwiLCJhdXRvbGluayIsInVybCIsInByZXZDYXBaZXJvIiwiX2JhY2twZWRhbCIsImlubGluZVRleHQiLCJibG9ja0NvZGUiLCJidWxsZXQiLCJfcGFyYWdyYXBoIiwiYmxvY2tUZXh0IiwiX2Jsb2NrTGFiZWwiLCJfdGFnIiwiX2NvbW1lbnQiLCJibG9ja05vcm1hbCIsImdmbVRhYmxlIiwiYmxvY2tHZm0iLCJibG9ja1BlZGFudGljIiwiaW5saW5lQ29kZSIsIl9wdW5jdHVhdGlvbiIsImJsb2NrU2tpcCIsIl9pbmxpbmVDb21tZW50IiwiX2lubGluZUxhYmVsIiwicmVmbGlua1NlYXJjaCIsImlubGluZU5vcm1hbCIsImlubGluZVBlZGFudGljIiwiaW5saW5lR2ZtIiwiaW5saW5lQnJlYWtzIiwibm9ybWFsIiwiX0xleGVyIiwiT2JqZWN0IiwiY3JlYXRlIiwiaW5saW5lUXVldWUiLCJsZXgiLCJsZXhJbmxpbmUiLCJuZXh0IiwibGVhZGluZyIsInRhYnMiLCJsYXN0VG9rZW4iLCJjdXRTcmMiLCJsYXN0UGFyYWdyYXBoQ2xpcHBlZCIsImV4dFRva2VuaXplciIsImNhbGwiLCJzdGFydEJsb2NrIiwic3RhcnRJbmRleCIsIkluZmluaXR5IiwidGVtcFNyYyIsInRlbXBTdGFydCIsImZvckVhY2giLCJnZXRTdGFydEluZGV4IiwiZXJyTXNnIiwiY2hhckNvZGVBdCIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwia2VlcFByZXZDaGFyIiwia2V5cyIsImluY2x1ZGVzIiwibGFzdEluZGV4T2YiLCJzdGFydElubGluZSIsIl9SZW5kZXJlciIsImluZm9zdHJpbmciLCJxdW90ZSIsImJvZHkiLCJzdGFydGF0dCIsImxpc3RpdGVtIiwiY2hlY2tib3giLCJ0YWJsZXJvdyIsImNvbnRlbnQiLCJ0YWJsZWNlbGwiLCJmbGFncyIsInN0cm9uZyIsImVtIiwiY2xlYW5IcmVmIiwib3V0IiwiaW1hZ2UiLCJfVGV4dFJlbmRlcmVyIiwiX1BhcnNlciIsInRleHRSZW5kZXJlciIsInBhcnNlIiwicGFyc2VyIiwicGFyc2VJbmxpbmUiLCJyZW5kZXJlcnMiLCJnZW5lcmljVG9rZW4iLCJyZXQiLCJoZWFkaW5nVG9rZW4iLCJjb2RlVG9rZW4iLCJ0YWJsZVRva2VuIiwiaiIsImsiLCJibG9ja3F1b3RlVG9rZW4iLCJsaXN0VG9rZW4iLCJpdGVtQm9keSIsInVuc2hpZnQiLCJodG1sVG9rZW4iLCJwYXJhZ3JhcGhUb2tlbiIsInRleHRUb2tlbiIsImVzY2FwZVRva2VuIiwidGFnVG9rZW4iLCJsaW5rVG9rZW4iLCJpbWFnZVRva2VuIiwic3Ryb25nVG9rZW4iLCJlbVRva2VuIiwiY29kZXNwYW5Ub2tlbiIsImRlbFRva2VuIiwiX0hvb2tzIiwicGFzc1Rocm91Z2hIb29rcyIsIlNldCIsInByZXByb2Nlc3MiLCJtYXJrZG93biIsInBvc3Rwcm9jZXNzIiwicHJvY2Vzc0FsbFRva2VucyIsIk1hcmtlZCIsImFyZ3MiLCJkZWZhdWx0cyIsInNldE9wdGlvbnMiLCJwYXJzZU1hcmtkb3duIiwiUGFyc2VyIiwiUmVuZGVyZXIiLCJUZXh0UmVuZGVyZXIiLCJMZXhlciIsIlRva2VuaXplciIsIkhvb2tzIiwidXNlIiwiY2FsbGJhY2siLCJ2YWx1ZXMiLCJjb25jYXQiLCJjaGlsZFRva2VucyIsImZsYXQiLCJwYWNrIiwib3B0cyIsImV4dCIsInByZXZSZW5kZXJlciIsImFwcGx5IiwiZXh0TGV2ZWwiLCJwcm9wIiwicmVuZGVyZXJQcm9wIiwicmVuZGVyZXJGdW5jIiwidG9rZW5pemVyUHJvcCIsInRva2VuaXplckZ1bmMiLCJwcmV2VG9rZW5pemVyIiwiaG9va3NQcm9wIiwiaG9va3NGdW5jIiwicHJldkhvb2siLCJoYXMiLCJhcmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJwYWNrV2Fsa3Rva2VucyIsIm9yaWdPcHQiLCJ3YXJuIiwidGhyb3dFcnJvciIsIm9uRXJyb3IiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImFsbCIsImNhdGNoIiwibWVzc2FnZSIsIm1zZyIsInJlamVjdCIsIm1hcmtlZEluc3RhbmNlIiwibWFya2VkIiwiZ2V0RGVmYXVsdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/marked/lib/marked.esm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/marked/lib/marked.esm.js":
/*!***********************************************!*\
  !*** ./node_modules/marked/lib/marked.esm.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hooks: () => (/* binding */ _Hooks),\n/* harmony export */   Lexer: () => (/* binding */ _Lexer),\n/* harmony export */   Marked: () => (/* binding */ Marked),\n/* harmony export */   Parser: () => (/* binding */ _Parser),\n/* harmony export */   Renderer: () => (/* binding */ _Renderer),\n/* harmony export */   TextRenderer: () => (/* binding */ _TextRenderer),\n/* harmony export */   Tokenizer: () => (/* binding */ _Tokenizer),\n/* harmony export */   defaults: () => (/* binding */ _defaults),\n/* harmony export */   getDefaults: () => (/* binding */ _getDefaults),\n/* harmony export */   lexer: () => (/* binding */ lexer),\n/* harmony export */   marked: () => (/* binding */ marked),\n/* harmony export */   options: () => (/* binding */ options),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseInline: () => (/* binding */ parseInline),\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   setOptions: () => (/* binding */ setOptions),\n/* harmony export */   use: () => (/* binding */ use),\n/* harmony export */   walkTokens: () => (/* binding */ walkTokens)\n/* harmony export */ });\n/**\n * marked v11.2.0 - a markdown parser\n * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ /**\n * Gets the original marked default options.\n */ function _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null\n    };\n}\nlet _defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n/**\n * Helpers\n */ const escapeTest = /[&<>\"']/;\nconst escapeReplace = new RegExp(escapeTest.source, \"g\");\nconst escapeTestNoEncode = /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/;\nconst escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, \"g\");\nconst escapeReplacements = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n};\nconst getEscapeReplacement = (ch)=>escapeReplacements[ch];\nfunction escape$1(html, encode) {\n    if (encode) {\n        if (escapeTest.test(html)) {\n            return html.replace(escapeReplace, getEscapeReplacement);\n        }\n    } else {\n        if (escapeTestNoEncode.test(html)) {\n            return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nconst unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\nfunction unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, (_, n)=>{\n        n = n.toLowerCase();\n        if (n === \"colon\") return \":\";\n        if (n.charAt(0) === \"#\") {\n            return n.charAt(1) === \"x\" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n        }\n        return \"\";\n    });\n}\nconst caret = /(^|[^\\[])\\^/g;\nfunction edit(regex, opt) {\n    let source = typeof regex === \"string\" ? regex : regex.source;\n    opt = opt || \"\";\n    const obj = {\n        replace: (name, val)=>{\n            let valSource = typeof val === \"string\" ? val : val.source;\n            valSource = valSource.replace(caret, \"$1\");\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: ()=>{\n            return new RegExp(source, opt);\n        }\n    };\n    return obj;\n}\nfunction cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(/%25/g, \"%\");\n    } catch (e) {\n        return null;\n    }\n    return href;\n}\nconst noopTest = {\n    exec: ()=>null\n};\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(/\\|/g, (match, offset, str)=>{\n        let escaped = false;\n        let curr = offset;\n        while(--curr >= 0 && str[curr] === \"\\\\\")escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return \"|\";\n        } else {\n            // add space before unescaped |\n            return \" |\";\n        }\n    }), cells = row.split(/ \\|/);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells[cells.length - 1].trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        } else {\n            while(cells.length < count)cells.push(\"\");\n        }\n    }\n    for(; i < cells.length; i++){\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(/\\\\\\|/g, \"|\");\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */ function rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return \"\";\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while(suffLen < l){\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && !invert) {\n            suffLen++;\n        } else if (currChar !== c && invert) {\n            suffLen++;\n        } else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for(let i = 0; i < str.length; i++){\n        if (str[i] === \"\\\\\") {\n            i++;\n        } else if (str[i] === b[0]) {\n            level++;\n        } else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\nfunction outputLink(cap, link, raw, lexer) {\n    const href = link.href;\n    const title = link.title ? escape$1(link.title) : null;\n    const text = cap[1].replace(/\\\\([\\[\\]])/g, \"$1\");\n    if (cap[0].charAt(0) !== \"!\") {\n        lexer.state.inLink = true;\n        const token = {\n            type: \"link\",\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text)\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: \"image\",\n        raw,\n        href,\n        title,\n        text: escape$1(text)\n    };\n}\nfunction indentCodeCompensation(raw, text) {\n    const matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text.split(\"\\n\").map((node)=>{\n        const matchIndentInNode = node.match(/^\\s+/);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    }).join(\"\\n\");\n}\n/**\n * Tokenizer\n */ class _Tokenizer {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: \"space\",\n                raw: cap[0]\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(/^ {1,4}/gm, \"\");\n            return {\n                type: \"code\",\n                raw: cap[0],\n                codeBlockStyle: \"indented\",\n                text: !this.options.pedantic ? rtrim(text, \"\\n\") : text\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || \"\");\n            return {\n                type: \"code\",\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, \"$1\") : cap[2],\n                text\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (/#$/.test(text)) {\n                const trimmed = rtrim(text, \"#\");\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                } else if (!trimmed || / $/.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: \"hr\",\n                raw: cap[0]\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            const text = rtrim(cap[0].replace(/^ *>[ \\t]?/gm, \"\"), \"\\n\");\n            const top = this.lexer.state.top;\n            this.lexer.state.top = true;\n            const tokens = this.lexer.blockTokens(text);\n            this.lexer.state.top = top;\n            return {\n                type: \"blockquote\",\n                raw: cap[0],\n                tokens,\n                text\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: \"list\",\n                raw: \"\",\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : \"\",\n                loose: false,\n                items: []\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : \"[*+-]\";\n            }\n            // Get next list item\n            const itemRegex = new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`);\n            let raw = \"\";\n            let itemContents = \"\";\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while(src){\n                let endEarly = false;\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) {\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split(\"\\n\", 1)[0].replace(/^\\t+/, (t)=>\" \".repeat(3 * t.length));\n                let nextLine = src.split(\"\\n\", 1)[0];\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                } else {\n                    indent = cap[2].search(/[^ ]/); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                let blankLine = false;\n                if (!line && /^ *$/.test(nextLine)) {\n                    raw += nextLine + \"\\n\";\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`);\n                    const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`);\n                    const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`);\n                    const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);\n                    // Check if following lines should be included in List Item\n                    while(src){\n                        const rawLine = src.split(\"\\n\", 1)[0];\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, \"  \");\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(src)) {\n                            break;\n                        }\n                        if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {\n                            itemContents += \"\\n\" + nextLine.slice(indent);\n                        } else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.search(/[^ ]/) >= 4) {\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += \"\\n\" + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) {\n                            blankLine = true;\n                        }\n                        raw += rawLine + \"\\n\";\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLine.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    } else if (/\\n *\\n *$/.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = /^\\[[ xX]\\] /.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== \"[ ] \";\n                        itemContents = itemContents.replace(/^\\[[ xX]\\] +/, \"\");\n                    }\n                }\n                list.items.push({\n                    type: \"list_item\",\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: []\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            list.items[list.items.length - 1].raw = raw.trimEnd();\n            list.items[list.items.length - 1].text = itemContents.trimEnd();\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for(let i = 0; i < list.items.length; i++){\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter((t)=>t.type === \"space\");\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t)=>/\\n.*\\n/.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for(let i = 0; i < list.items.length; i++){\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: \"html\",\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === \"pre\" || cap[1] === \"script\" || cap[1] === \"style\",\n                text: cap[0]\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(/\\s+/g, \" \");\n            const href = cap[2] ? cap[2].replace(/^<(.*)>$/, \"$1\").replace(this.rules.inline.anyPunctuation, \"$1\") : \"\";\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, \"$1\") : cap[3];\n            return {\n                type: \"def\",\n                tag,\n                raw: cap[0],\n                href,\n                title\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!/[:|]/.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(/^\\||\\| *$/g, \"\").split(\"|\");\n        const rows = cap[3] && cap[3].trim() ? cap[3].replace(/\\n[ \\t]*$/, \"\").split(\"\\n\") : [];\n        const item = {\n            type: \"table\",\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: []\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns){\n            if (/^ *-+: *$/.test(align)) {\n                item.align.push(\"right\");\n            } else if (/^ *:-+: *$/.test(align)) {\n                item.align.push(\"center\");\n            } else if (/^ *:-+ *$/.test(align)) {\n                item.align.push(\"left\");\n            } else {\n                item.align.push(null);\n            }\n        }\n        for (const header of headers){\n            item.header.push({\n                text: header,\n                tokens: this.lexer.inline(header)\n            });\n        }\n        for (const row of rows){\n            item.rows.push(splitCells(row, item.header.length).map((cell)=>{\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell)\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: \"heading\",\n                raw: cap[0],\n                depth: cap[2].charAt(0) === \"=\" ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1])\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === \"\\n\" ? cap[1].slice(0, -1) : cap[1];\n            return {\n                type: \"paragraph\",\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text)\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0])\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: \"escape\",\n                raw: cap[0],\n                text: escape$1(cap[1])\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            } else if (this.lexer.state.inLink && /^<\\/a>/i.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            } else if (this.lexer.state.inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: \"html\",\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0]\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!/>$/.test(trimmedUrl)) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), \"\\\\\");\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            } else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], \"()\");\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf(\"!\") === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = \"\";\n                }\n            }\n            let href = cap[2];\n            let title = \"\";\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            } else {\n                title = cap[3] ? cap[3].slice(1, -1) : \"\";\n            }\n            href = href.trim();\n            if (/^</.test(href)) {\n                if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                } else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, \"$1\") : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, \"$1\") : title\n            }, cap[0], this.lexer);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(/\\s+/g, \" \");\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: \"text\",\n                    raw: text,\n                    text\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = \"\") {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match) return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(/[\\p{L}\\p{N}]/u)) return;\n        const nextChar = match[1] || match[2] || \"\";\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [\n                ...match[0]\n            ].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === \"*\" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while((match = endReg.exec(maskedSrc)) != null){\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim) continue; // skip single * in __abc*abc__\n                rLength = [\n                    ...rDelim\n                ].length;\n                if (match[3] || match[4]) {\n                    delimTotal += rLength;\n                    continue;\n                } else if (match[5] || match[6]) {\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [\n                    ...match[0]\n                ][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: \"em\",\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text)\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: \"strong\",\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text)\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(/\\n/g, \" \");\n            const hasNonSpaceChars = /[^ ]/.test(text);\n            const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            text = escape$1(text, true);\n            return {\n                type: \"codespan\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: \"br\",\n                raw: cap[0]\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: \"del\",\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2])\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = escape$1(cap[1]);\n                href = \"mailto:\" + text;\n            } else {\n                text = escape$1(cap[1]);\n                href = text;\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === \"@\") {\n                text = escape$1(cap[0]);\n                href = \"mailto:\" + text;\n            } else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? \"\";\n                }while (prevCapZero !== cap[0]);\n                text = escape$1(cap[0]);\n                if (cap[1] === \"www.\") {\n                    href = \"http://\" + cap[0];\n                } else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: \"link\",\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: \"text\",\n                        raw: text,\n                        text\n                    }\n                ]\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            let text;\n            if (this.lexer.state.inRawBlock) {\n                text = cap[0];\n            } else {\n                text = escape$1(cap[0]);\n            }\n            return {\n                type: \"text\",\n                raw: cap[0],\n                text\n            };\n        }\n    }\n}\n/**\n * Block-Level Grammar\n */ const newline = /^(?: *(?:\\n|$))+/;\nconst blockCode = /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheading = edit(/^(?!bull )((?:.|\\n(?!\\s*?\\n|bull ))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/).replace(/bull/g, bullet) // lists can interrupt\n.getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n *)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n *)?| *\\n *)(title))? *(?:\\n+|$)/).replace(\"label\", _blockLabel).replace(\"title\", /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, bullet).getRegex();\nconst _tag = \"address|article|aside|base|basefont|blockquote|body|caption\" + \"|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption\" + \"|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe\" + \"|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option\" + \"|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr\" + \"|track|ul\";\nconst _comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\nconst html = edit(\"^ {0,3}(?:\" // optional indentation\n + \"<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)\" // (1)\n + \"|comment[^\\\\n]*(\\\\n+|$)\" // (2)\n + \"|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)\" // (3)\n + \"|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)\" // (4)\n + \"|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)\" // (5)\n + \"|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (6)\n + \"|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) open tag\n + \"|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n *)+\\\\n|$)\" // (7) closing tag\n + \")\", \"i\").replace(\"comment\", _comment).replace(\"tag\", _tag).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\nconst paragraph = edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n.replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n.getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace(\"paragraph\", paragraph).getRegex();\n/**\n * Normal Block Grammar\n */ const blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText\n};\n/**\n * GFM Block Grammar\n */ const gfmTable = edit(\"^ *([^\\\\n ].*)\\\\n\" // Header\n + \" {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)\" // Align\n + \"(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\") // Cells\n.replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \" {4}[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n.replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // tables can be interrupted by type (6) html blocks\n.getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    table: gfmTable,\n    paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\") // setex headings don't interrupt commonmark paragraphs\n    .replace(\"table\", gfmTable) // interrupt paragraphs with table\n    .replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \") // only lists starting from 1 can interrupt\n    .replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex()\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */ const blockPedantic = {\n    ...blockNormal,\n    html: edit(\"^ *(?:comment *(?:\\\\n|\\\\s*$)\" + \"|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)\" // closed tag\n     + \"|<tag(?:\\\"[^\\\"]*\\\"|'[^']*'|\\\\s[^'\\\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))\").replace(\"comment\", _comment).replace(/tag/g, \"(?!(?:\" + \"a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub\" + \"|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\" + \"\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest,\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph).replace(\"hr\", hr).replace(\"heading\", \" *#{1,6} *[^\\n]\").replace(\"lheading\", lheading).replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").replace(\"|tag\", \"\").getRegex()\n};\n/**\n * Inline-Level Grammar\n */ const escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = \"\\\\p{P}$+<=>`^|~\";\nconst punctuation = edit(/^((?![*_])[\\spunctuation])/, \"u\").replace(/punctuation/g, _punctuation).getRegex();\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\([^\\(\\)]*?\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelim = edit(/^(?:\\*+(?:((?!\\*)[punct])|[^\\s*]))|^_+(?:((?!_)[punct])|([^\\s_]))/, \"u\").replace(/punct/g, _punctuation).getRegex();\nconst emStrongRDelimAst = edit(\"^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)\" // Skip orphan inside strong\n + \"|[^*]+(?=[^*])\" // Consume to delim\n + \"|(?!\\\\*)[punct](\\\\*+)(?=[\\\\s]|$)\" // (1) #*** can only be a Right Delimiter\n + \"|[^punct\\\\s](\\\\*+)(?!\\\\*)(?=[punct\\\\s]|$)\" // (2) a***#, a*** can only be a Right Delimiter\n + \"|(?!\\\\*)[punct\\\\s](\\\\*+)(?=[^punct\\\\s])\" // (3) #***a, ***a can only be Left Delimiter\n + \"|[\\\\s](\\\\*+)(?!\\\\*)(?=[punct])\" // (4) ***# can only be Left Delimiter\n + \"|(?!\\\\*)[punct](\\\\*+)(?!\\\\*)(?=[punct])\" // (5) #***# can be either Left or Right Delimiter\n + \"|[^punct\\\\s](\\\\*+)(?=[^punct\\\\s])\", \"gu\") // (6) a***a can be either Left or Right Delimiter\n.replace(/punct/g, _punctuation).getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit(\"^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)\" // Skip orphan inside strong\n + \"|[^_]+(?=[^_])\" // Consume to delim\n + \"|(?!_)[punct](_+)(?=[\\\\s]|$)\" // (1) #___ can only be a Right Delimiter\n + \"|[^punct\\\\s](_+)(?!_)(?=[punct\\\\s]|$)\" // (2) a___#, a___ can only be a Right Delimiter\n + \"|(?!_)[punct\\\\s](_+)(?=[^punct\\\\s])\" // (3) #___a, ___a can only be Left Delimiter\n + \"|[\\\\s](_+)(?!_)(?=[punct])\" // (4) ___# can only be Left Delimiter\n + \"|(?!_)[punct](_+)(?!_)(?=[punct])\", \"gu\") // (5) #___# can be either Left or Right Delimiter\n.replace(/punct/g, _punctuation).getRegex();\nconst anyPunctuation = edit(/\\\\([punct])/, \"gu\").replace(/punct/g, _punctuation).getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace(\"scheme\", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace(\"email\", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();\nconst _inlineComment = edit(_comment).replace(\"(?:-->|$)\", \"-->\").getRegex();\nconst tag = edit(\"^comment\" + \"|^</[a-zA-Z][\\\\w:-]*\\\\s*>\" // self-closing tag\n + \"|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>\" // open tag\n + \"|^<\\\\?[\\\\s\\\\S]*?\\\\?>\" // processing instruction, e.g. <?php ?>\n + \"|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>\" // declaration, e.g. <!DOCTYPE html>\n + \"|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\") // CDATA section\n.replace(\"comment\", _inlineComment).replace(\"attribute\", /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/).replace(\"label\", _inlineLabel).replace(\"href\", /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/).replace(\"title\", /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/).replace(\"label\", _inlineLabel).replace(\"ref\", _blockLabel).getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/).replace(\"ref\", _blockLabel).getRegex();\nconst reflinkSearch = edit(\"reflink|nolink(?!\\\\()\", \"g\").replace(\"reflink\", reflink).replace(\"nolink\", nolink).getRegex();\n/**\n * Normal Inline Grammar\n */ const inlineNormal = {\n    _backpedal: noopTest,\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest\n};\n/**\n * Pedantic Inline Grammar\n */ const inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", _inlineLabel).getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", _inlineLabel).getRegex()\n};\n/**\n * GFM Inline Grammar\n */ const inlineGfm = {\n    ...inlineNormal,\n    escape: edit(escape).replace(\"])\", \"~|])\").getRegex(),\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, \"i\").replace(\"email\", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */ const inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace(\"{2,}\", \"*\").getRegex(),\n    text: edit(inlineGfm.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n};\n/**\n * exports\n */ const block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic\n};\nconst inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic\n};\n/**\n * Block Lexer\n */ class _Lexer {\n    constructor(options){\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true\n        };\n        const rules = {\n            block: block.normal,\n            inline: inline.normal\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        } else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            } else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */ static get rules() {\n        return {\n            block,\n            inline\n        };\n    }\n    /**\n     * Static Lex Method\n     */ static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */ static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */ lex(src) {\n        src = src.replace(/\\r\\n|\\r/g, \"\\n\");\n        this.blockTokens(src, this.tokens);\n        for(let i = 0; i < this.inlineQueue.length; i++){\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = []) {\n        if (this.options.pedantic) {\n            src = src.replace(/\\t/g, \"    \").replace(/^ +$/gm, \"\");\n        } else {\n            src = src.replace(/^( *)(\\t+)/gm, (_, leading, tabs)=>{\n                return leading + \"    \".repeat(tabs.length);\n            });\n        }\n        let token;\n        let lastToken;\n        let cutSrc;\n        let lastParagraphClipped;\n        while(src){\n            if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.length === 1 && tokens.length > 0) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    tokens[tokens.length - 1].raw += \"\\n\";\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && (lastToken.type === \"paragraph\" || lastToken.type === \"text\")) {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.raw;\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                lastToken = tokens[tokens.length - 1];\n                if (lastParagraphClipped && lastToken.type === \"paragraph\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += \"\\n\" + token.raw;\n                    lastToken.text += \"\\n\" + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({\n            src,\n            tokens\n        });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */ inlineTokens(src, tokens = []) {\n        let token, lastToken, cutSrc;\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match;\n        let keepPrevChar, prevChar;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null){\n                    if (links.includes(match[0].slice(match[0].lastIndexOf(\"[\") + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"[\" + \"a\".repeat(match[0].length - 2) + \"]\" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null){\n            maskedSrc = maskedSrc.slice(0, match.index) + \"++\" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        while(src){\n            if (!keepPrevChar) {\n                prevChar = \"\";\n            }\n            keepPrevChar = false;\n            // extensions\n            if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer)=>{\n                if (token = extTokenizer.call({\n                    lexer: this\n                }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && token.type === \"text\" && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            cutSrc = src;\n            if (this.options.extensions && this.options.extensions.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex)=>{\n                    tempStart = getStartIndex.call({\n                        lexer: this\n                    }, tempSrc);\n                    if (typeof tempStart === \"number\" && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== \"_\") {\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                lastToken = tokens[tokens.length - 1];\n                if (lastToken && lastToken.type === \"text\") {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                } else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = \"Infinite loop on byte: \" + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                } else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n/**\n * Renderer\n */ class _Renderer {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    code(code, infostring, escaped) {\n        const lang = (infostring || \"\").match(/^\\S*/)?.[0];\n        code = code.replace(/\\n$/, \"\") + \"\\n\";\n        if (!lang) {\n            return \"<pre><code>\" + (escaped ? code : escape$1(code, true)) + \"</code></pre>\\n\";\n        }\n        return '<pre><code class=\"language-' + escape$1(lang) + '\">' + (escaped ? code : escape$1(code, true)) + \"</code></pre>\\n\";\n    }\n    blockquote(quote) {\n        return `<blockquote>\\n${quote}</blockquote>\\n`;\n    }\n    html(html, block) {\n        return html;\n    }\n    heading(text, level, raw) {\n        // ignore IDs\n        return `<h${level}>${text}</h${level}>\\n`;\n    }\n    hr() {\n        return \"<hr>\\n\";\n    }\n    list(body, ordered, start) {\n        const type = ordered ? \"ol\" : \"ul\";\n        const startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : \"\";\n        return \"<\" + type + startatt + \">\\n\" + body + \"</\" + type + \">\\n\";\n    }\n    listitem(text, task, checked) {\n        return `<li>${text}</li>\\n`;\n    }\n    checkbox(checked) {\n        return \"<input \" + (checked ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph(text) {\n        return `<p>${text}</p>\\n`;\n    }\n    table(header, body) {\n        if (body) body = `<tbody>${body}</tbody>`;\n        return \"<table>\\n\" + \"<thead>\\n\" + header + \"</thead>\\n\" + body + \"</table>\\n\";\n    }\n    tablerow(content) {\n        return `<tr>\\n${content}</tr>\\n`;\n    }\n    tablecell(content, flags) {\n        const type = flags.header ? \"th\" : \"td\";\n        const tag = flags.align ? `<${type} align=\"${flags.align}\">` : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */ strong(text) {\n        return `<strong>${text}</strong>`;\n    }\n    em(text) {\n        return `<em>${text}</em>`;\n    }\n    codespan(text) {\n        return `<code>${text}</code>`;\n    }\n    br() {\n        return \"<br>\";\n    }\n    del(text) {\n        return `<del>${text}</del>`;\n    }\n    link(href, title, text) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + title + '\"';\n        }\n        out += \">\" + text + \"</a>\";\n        return out;\n    }\n    image(href, title, text) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${title}\"`;\n        }\n        out += \">\";\n        return out;\n    }\n    text(text) {\n        return text;\n    }\n}\n/**\n * TextRenderer\n * returns only the textual part of the token\n */ class _TextRenderer {\n    // no need for block level renderers\n    strong(text) {\n        return text;\n    }\n    em(text) {\n        return text;\n    }\n    codespan(text) {\n        return text;\n    }\n    del(text) {\n        return text;\n    }\n    html(text) {\n        return text;\n    }\n    text(text) {\n        return text;\n    }\n    link(href, title, text) {\n        return \"\" + text;\n    }\n    image(href, title, text) {\n        return \"\" + text;\n    }\n    br() {\n        return \"\";\n    }\n}\n/**\n * Parsing & Compiling\n */ class _Parser {\n    constructor(options){\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */ static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */ static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */ parse(tokens, top = true) {\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const genericToken = token;\n                const ret = this.options.extensions.renderers[genericToken.type].call({\n                    parser: this\n                }, genericToken);\n                if (ret !== false || ![\n                    \"space\",\n                    \"hr\",\n                    \"heading\",\n                    \"code\",\n                    \"table\",\n                    \"blockquote\",\n                    \"list\",\n                    \"html\",\n                    \"paragraph\",\n                    \"text\"\n                ].includes(genericToken.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"space\":\n                    {\n                        continue;\n                    }\n                case \"hr\":\n                    {\n                        out += this.renderer.hr();\n                        continue;\n                    }\n                case \"heading\":\n                    {\n                        const headingToken = token;\n                        out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));\n                        continue;\n                    }\n                case \"code\":\n                    {\n                        const codeToken = token;\n                        out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);\n                        continue;\n                    }\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        let header = \"\";\n                        // header\n                        let cell = \"\";\n                        for(let j = 0; j < tableToken.header.length; j++){\n                            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), {\n                                header: true,\n                                align: tableToken.align[j]\n                            });\n                        }\n                        header += this.renderer.tablerow(cell);\n                        let body = \"\";\n                        for(let j = 0; j < tableToken.rows.length; j++){\n                            const row = tableToken.rows[j];\n                            cell = \"\";\n                            for(let k = 0; k < row.length; k++){\n                                cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {\n                                    header: false,\n                                    align: tableToken.align[k]\n                                });\n                            }\n                            body += this.renderer.tablerow(cell);\n                        }\n                        out += this.renderer.table(header, body);\n                        continue;\n                    }\n                case \"blockquote\":\n                    {\n                        const blockquoteToken = token;\n                        const body = this.parse(blockquoteToken.tokens);\n                        out += this.renderer.blockquote(body);\n                        continue;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        const ordered = listToken.ordered;\n                        const start = listToken.start;\n                        const loose = listToken.loose;\n                        let body = \"\";\n                        for(let j = 0; j < listToken.items.length; j++){\n                            const item = listToken.items[j];\n                            const checked = item.checked;\n                            const task = item.task;\n                            let itemBody = \"\";\n                            if (item.task) {\n                                const checkbox = this.renderer.checkbox(!!checked);\n                                if (loose) {\n                                    if (item.tokens.length > 0 && item.tokens[0].type === \"paragraph\") {\n                                        item.tokens[0].text = checkbox + \" \" + item.tokens[0].text;\n                                        if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === \"text\") {\n                                            item.tokens[0].tokens[0].text = checkbox + \" \" + item.tokens[0].tokens[0].text;\n                                        }\n                                    } else {\n                                        item.tokens.unshift({\n                                            type: \"text\",\n                                            text: checkbox + \" \"\n                                        });\n                                    }\n                                } else {\n                                    itemBody += checkbox + \" \";\n                                }\n                            }\n                            itemBody += this.parse(item.tokens, loose);\n                            body += this.renderer.listitem(itemBody, task, !!checked);\n                        }\n                        out += this.renderer.list(body, ordered, start);\n                        continue;\n                    }\n                case \"html\":\n                    {\n                        const htmlToken = token;\n                        out += this.renderer.html(htmlToken.text, htmlToken.block);\n                        continue;\n                    }\n                case \"paragraph\":\n                    {\n                        const paragraphToken = token;\n                        out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));\n                        continue;\n                    }\n                case \"text\":\n                    {\n                        let textToken = token;\n                        let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;\n                        while(i + 1 < tokens.length && tokens[i + 1].type === \"text\"){\n                            textToken = tokens[++i];\n                            body += \"\\n\" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);\n                        }\n                        out += top ? this.renderer.paragraph(body) : body;\n                        continue;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */ parseInline(tokens, renderer) {\n        renderer = renderer || this.renderer;\n        let out = \"\";\n        for(let i = 0; i < tokens.length; i++){\n            const token = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {\n                const ret = this.options.extensions.renderers[token.type].call({\n                    parser: this\n                }, token);\n                if (ret !== false || ![\n                    \"escape\",\n                    \"html\",\n                    \"link\",\n                    \"image\",\n                    \"strong\",\n                    \"em\",\n                    \"codespan\",\n                    \"br\",\n                    \"del\",\n                    \"text\"\n                ].includes(token.type)) {\n                    out += ret || \"\";\n                    continue;\n                }\n            }\n            switch(token.type){\n                case \"escape\":\n                    {\n                        const escapeToken = token;\n                        out += renderer.text(escapeToken.text);\n                        break;\n                    }\n                case \"html\":\n                    {\n                        const tagToken = token;\n                        out += renderer.html(tagToken.text);\n                        break;\n                    }\n                case \"link\":\n                    {\n                        const linkToken = token;\n                        out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));\n                        break;\n                    }\n                case \"image\":\n                    {\n                        const imageToken = token;\n                        out += renderer.image(imageToken.href, imageToken.title, imageToken.text);\n                        break;\n                    }\n                case \"strong\":\n                    {\n                        const strongToken = token;\n                        out += renderer.strong(this.parseInline(strongToken.tokens, renderer));\n                        break;\n                    }\n                case \"em\":\n                    {\n                        const emToken = token;\n                        out += renderer.em(this.parseInline(emToken.tokens, renderer));\n                        break;\n                    }\n                case \"codespan\":\n                    {\n                        const codespanToken = token;\n                        out += renderer.codespan(codespanToken.text);\n                        break;\n                    }\n                case \"br\":\n                    {\n                        out += renderer.br();\n                        break;\n                    }\n                case \"del\":\n                    {\n                        const delToken = token;\n                        out += renderer.del(this.parseInline(delToken.tokens, renderer));\n                        break;\n                    }\n                case \"text\":\n                    {\n                        const textToken = token;\n                        out += renderer.text(textToken.text);\n                        break;\n                    }\n                default:\n                    {\n                        const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                        if (this.options.silent) {\n                            console.error(errMsg);\n                            return \"\";\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    }\n            }\n        }\n        return out;\n    }\n}\nclass _Hooks {\n    constructor(options){\n        this.options = options || _defaults;\n    }\n    static{\n        this.passThroughHooks = new Set([\n            \"preprocess\",\n            \"postprocess\",\n            \"processAllTokens\"\n        ]);\n    }\n    /**\n     * Process markdown before marked\n     */ preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */ postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */ processAllTokens(tokens) {\n        return tokens;\n    }\n}\nclass Marked {\n    constructor(...args){\n        this.defaults = _getDefaults();\n        this.options = this.setOptions;\n        this.parse = this.#parseMarkdown(_Lexer.lex, _Parser.parse);\n        this.parseInline = this.#parseMarkdown(_Lexer.lexInline, _Parser.parseInline);\n        this.Parser = _Parser;\n        this.Renderer = _Renderer;\n        this.TextRenderer = _TextRenderer;\n        this.Lexer = _Lexer;\n        this.Tokenizer = _Tokenizer;\n        this.Hooks = _Hooks;\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */ walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens){\n            values = values.concat(callback.call(this, token));\n            switch(token.type){\n                case \"table\":\n                    {\n                        const tableToken = token;\n                        for (const cell of tableToken.header){\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                        for (const row of tableToken.rows){\n                            for (const cell of row){\n                                values = values.concat(this.walkTokens(cell.tokens, callback));\n                            }\n                        }\n                        break;\n                    }\n                case \"list\":\n                    {\n                        const listToken = token;\n                        values = values.concat(this.walkTokens(listToken.items, callback));\n                        break;\n                    }\n                default:\n                    {\n                        const genericToken = token;\n                        if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens)=>{\n                                const tokens = genericToken[childTokens].flat(Infinity);\n                                values = values.concat(this.walkTokens(tokens, callback));\n                            });\n                        } else if (genericToken.tokens) {\n                            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                        }\n                    }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || {\n            renderers: {},\n            childTokens: {}\n        };\n        args.forEach((pack)=>{\n            // copy options to new object\n            const opts = {\n                ...pack\n            };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext)=>{\n                    if (!ext.name) {\n                        throw new Error(\"extension name required\");\n                    }\n                    if (\"renderer\" in ext) {\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function(...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        } else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if (\"tokenizer\" in ext) {\n                        if (!ext.level || ext.level !== \"block\" && ext.level !== \"inline\") {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        } else {\n                            extensions[ext.level] = [\n                                ext.tokenizer\n                            ];\n                        }\n                        if (ext.start) {\n                            if (ext.level === \"block\") {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                } else {\n                                    extensions.startBlock = [\n                                        ext.start\n                                    ];\n                                }\n                            } else if (ext.level === \"inline\") {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                } else {\n                                    extensions.startInline = [\n                                        ext.start\n                                    ];\n                                }\n                            }\n                        }\n                    }\n                    if (\"childTokens\" in ext && ext.childTokens) {\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for(const prop in pack.renderer){\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (prop === \"options\") {\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args)=>{\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || \"\";\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for(const prop in pack.tokenizer){\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if ([\n                        \"options\",\n                        \"rules\",\n                        \"lexer\"\n                    ].includes(prop)) {\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args)=>{\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for(const prop in pack.hooks){\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (prop === \"options\") {\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg)=>{\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret)=>{\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    } else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args)=>{\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function(token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = {\n                ...this.defaults,\n                ...opts\n            };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = {\n            ...this.defaults,\n            ...opt\n        };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    #parseMarkdown(lexer, parser) {\n        return (src, options)=>{\n            const origOpt = {\n                ...options\n            };\n            const opt = {\n                ...this.defaults,\n                ...origOpt\n            };\n            // Show warning if an extension set async to true but the parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                if (!opt.silent) {\n                    console.warn(\"marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.\");\n                }\n                opt.async = true;\n            }\n            const throwError = this.#onError(!!opt.silent, !!opt.async);\n            // throw error in case of non string input\n            if (typeof src === \"undefined\" || src === null) {\n                return throwError(new Error(\"marked(): input parameter is undefined or null\"));\n            }\n            if (typeof src !== \"string\") {\n                return throwError(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(src) + \", string expected\"));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n            }\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src)=>lexer(src, opt)).then((tokens)=>opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens).then((tokens)=>opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(()=>tokens) : tokens).then((tokens)=>parser(tokens, opt)).then((html)=>opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            } catch (e) {\n                return throwError(e);\n            }\n        };\n    }\n    #onError(silent, async) {\n        return (e)=>{\n            e.message += \"\\nPlease report this to https://github.com/markedjs/marked.\";\n            if (silent) {\n                const msg = \"<p>An error occurred:</p><pre>\" + escape$1(e.message + \"\", true) + \"</pre>\";\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\nconst markedInstance = new Marked();\nfunction marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */ marked.options = marked.setOptions = function(options) {\n    markedInstance.setOptions(options);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Gets the original marked default options.\n */ marked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */ marked.use = function(...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */ marked.walkTokens = function(tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */ marked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */ marked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\n //# sourceMappingURL=marked.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FFRDs7O0NBR0MsR0FFRDs7Q0FFQyxHQUNELFNBQVNBO0lBQ0wsT0FBTztRQUNIQyxPQUFPO1FBQ1BDLFFBQVE7UUFDUkMsWUFBWTtRQUNaQyxLQUFLO1FBQ0xDLE9BQU87UUFDUEMsVUFBVTtRQUNWQyxVQUFVO1FBQ1ZDLFFBQVE7UUFDUkMsV0FBVztRQUNYQyxZQUFZO0lBQ2hCO0FBQ0o7QUFDQSxJQUFJQyxZQUFZWDtBQUNoQixTQUFTWSxlQUFlQyxXQUFXO0lBQy9CRixZQUFZRTtBQUNoQjtBQUVBOztDQUVDLEdBQ0QsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxnQkFBZ0IsSUFBSUMsT0FBT0YsV0FBV0csTUFBTSxFQUFFO0FBQ3BELE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyx3QkFBd0IsSUFBSUgsT0FBT0UsbUJBQW1CRCxNQUFNLEVBQUU7QUFDcEUsTUFBTUcscUJBQXFCO0lBQ3ZCLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0FBQ1Q7QUFDQSxNQUFNQyx1QkFBdUIsQ0FBQ0MsS0FBT0Ysa0JBQWtCLENBQUNFLEdBQUc7QUFDM0QsU0FBU0MsU0FBU0MsSUFBSSxFQUFFQyxNQUFNO0lBQzFCLElBQUlBLFFBQVE7UUFDUixJQUFJWCxXQUFXWSxJQUFJLENBQUNGLE9BQU87WUFDdkIsT0FBT0EsS0FBS0csT0FBTyxDQUFDWixlQUFlTTtRQUN2QztJQUNKLE9BQ0s7UUFDRCxJQUFJSCxtQkFBbUJRLElBQUksQ0FBQ0YsT0FBTztZQUMvQixPQUFPQSxLQUFLRyxPQUFPLENBQUNSLHVCQUF1QkU7UUFDL0M7SUFDSjtJQUNBLE9BQU9HO0FBQ1g7QUFDQSxNQUFNSSxlQUFlO0FBQ3JCLFNBQVNDLFNBQVNMLElBQUk7SUFDbEIseURBQXlEO0lBQ3pELE9BQU9B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T0FBTzdDLE1BQU0sR0FBR3hDO0FBQ2hCcUYsT0FBT2xGLE1BQU0sR0FBR0gsUUFBUUUsS0FBSztBQUM3Qm1GLE9BQU81QyxRQUFRLEdBQUcxRDtBQUNsQnNHLE9BQU8zQyxZQUFZLEdBQUczQztBQUN0QnNGLE9BQU8xQyxLQUFLLEdBQUczRjtBQUNmcUksT0FBT3RSLEtBQUssR0FBR2lKLE9BQU9JLEdBQUc7QUFDekJpSSxPQUFPekMsU0FBUyxHQUFHNU47QUFDbkJxUSxPQUFPeEMsS0FBSyxHQUFHakI7QUFDZnlELE9BQU9uRixLQUFLLEdBQUdtRjtBQUNmLE1BQU1uUSxVQUFVbVEsT0FBT25RLE9BQU87QUFDOUIsTUFBTW9OLGFBQWErQyxPQUFPL0MsVUFBVTtBQUNwQyxNQUFNUSxNQUFNdUMsT0FBT3ZDLEdBQUc7QUFDdEIsTUFBTTNULGFBQWFrVyxPQUFPbFcsVUFBVTtBQUNwQyxNQUFNaVIsY0FBY2lGLE9BQU9qRixXQUFXO0FBQ3RDLE1BQU1GLFFBQVFtRjtBQUNkLE1BQU1sRixTQUFTSCxRQUFRRSxLQUFLO0FBQzVCLE1BQU1uTSxRQUFRaUosT0FBT0ksR0FBRztBQUVtUSxDQUMzUixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9rYXJpYW0vLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuZXNtLmpzP2M3MzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBtYXJrZWQgdjExLjIuMCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAyNCwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZWRqcy9tYXJrZWRcbiAqL1xuXG4vKipcbiAqIERPIE5PVCBFRElUIFRISVMgRklMRVxuICogVGhlIGNvZGUgaW4gdGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIGZpbGVzIGluIC4vc3JjL1xuICovXG5cbi8qKlxuICogR2V0cyB0aGUgb3JpZ2luYWwgbWFya2VkIGRlZmF1bHQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgYnJlYWtzOiBmYWxzZSxcbiAgICAgICAgZXh0ZW5zaW9uczogbnVsbCxcbiAgICAgICAgZ2ZtOiB0cnVlLFxuICAgICAgICBob29rczogbnVsbCxcbiAgICAgICAgcGVkYW50aWM6IGZhbHNlLFxuICAgICAgICByZW5kZXJlcjogbnVsbCxcbiAgICAgICAgc2lsZW50OiBmYWxzZSxcbiAgICAgICAgdG9rZW5pemVyOiBudWxsLFxuICAgICAgICB3YWxrVG9rZW5zOiBudWxsXG4gICAgfTtcbn1cbmxldCBfZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbmZ1bmN0aW9uIGNoYW5nZURlZmF1bHRzKG5ld0RlZmF1bHRzKSB7XG4gICAgX2RlZmF1bHRzID0gbmV3RGVmYXVsdHM7XG59XG5cbi8qKlxuICogSGVscGVyc1xuICovXG5jb25zdCBlc2NhcGVUZXN0ID0gL1smPD5cIiddLztcbmNvbnN0IGVzY2FwZVJlcGxhY2UgPSBuZXcgUmVnRXhwKGVzY2FwZVRlc3Quc291cmNlLCAnZycpO1xuY29uc3QgZXNjYXBlVGVzdE5vRW5jb2RlID0gL1s8PlwiJ118Jig/ISgjXFxkezEsN318I1tYeF1bYS1mQS1GMC05XXsxLDZ9fFxcdyspOykvO1xuY29uc3QgZXNjYXBlUmVwbGFjZU5vRW5jb2RlID0gbmV3IFJlZ0V4cChlc2NhcGVUZXN0Tm9FbmNvZGUuc291cmNlLCAnZycpO1xuY29uc3QgZXNjYXBlUmVwbGFjZW1lbnRzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xufTtcbmNvbnN0IGdldEVzY2FwZVJlcGxhY2VtZW50ID0gKGNoKSA9PiBlc2NhcGVSZXBsYWNlbWVudHNbY2hdO1xuZnVuY3Rpb24gZXNjYXBlJDEoaHRtbCwgZW5jb2RlKSB7XG4gICAgaWYgKGVuY29kZSkge1xuICAgICAgICBpZiAoZXNjYXBlVGVzdC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2VOb0VuY29kZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xufVxuY29uc3QgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcbmZ1bmN0aW9uIHVuZXNjYXBlKGh0bWwpIHtcbiAgICAvLyBleHBsaWNpdGx5IG1hdGNoIGRlY2ltYWwsIGhleCwgYW5kIG5hbWVkIEhUTUwgZW50aXRpZXNcbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKHVuZXNjYXBlVGVzdCwgKF8sIG4pID0+IHtcbiAgICAgICAgbiA9IG4udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKG4gPT09ICdjb2xvbicpXG4gICAgICAgICAgICByZXR1cm4gJzonO1xuICAgICAgICBpZiAobi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgICAgcmV0dXJuIG4uY2hhckF0KDEpID09PSAneCdcbiAgICAgICAgICAgICAgICA/IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQobi5zdWJzdHJpbmcoMiksIDE2KSlcbiAgICAgICAgICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG59XG5jb25zdCBjYXJldCA9IC8oXnxbXlxcW10pXFxeL2c7XG5mdW5jdGlvbiBlZGl0KHJlZ2V4LCBvcHQpIHtcbiAgICBsZXQgc291cmNlID0gdHlwZW9mIHJlZ2V4ID09PSAnc3RyaW5nJyA/IHJlZ2V4IDogcmVnZXguc291cmNlO1xuICAgIG9wdCA9IG9wdCB8fCAnJztcbiAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIHJlcGxhY2U6IChuYW1lLCB2YWwpID0+IHtcbiAgICAgICAgICAgIGxldCB2YWxTb3VyY2UgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/IHZhbCA6IHZhbC5zb3VyY2U7XG4gICAgICAgICAgICB2YWxTb3VyY2UgPSB2YWxTb3VyY2UucmVwbGFjZShjYXJldCwgJyQxJyk7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZShuYW1lLCB2YWxTb3VyY2UpO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UmVnZXg6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgb3B0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGNsZWFuVXJsKGhyZWYpIHtcbiAgICB0cnkge1xuICAgICAgICBocmVmID0gZW5jb2RlVVJJKGhyZWYpLnJlcGxhY2UoLyUyNS9nLCAnJScpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGhyZWY7XG59XG5jb25zdCBub29wVGVzdCA9IHsgZXhlYzogKCkgPT4gbnVsbCB9O1xuZnVuY3Rpb24gc3BsaXRDZWxscyh0YWJsZVJvdywgY291bnQpIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBldmVyeSBjZWxsLWRlbGltaXRpbmcgcGlwZSBoYXMgYSBzcGFjZVxuICAgIC8vIGJlZm9yZSBpdCB0byBkaXN0aW5ndWlzaCBpdCBmcm9tIGFuIGVzY2FwZWQgcGlwZVxuICAgIGNvbnN0IHJvdyA9IHRhYmxlUm93LnJlcGxhY2UoL1xcfC9nLCAobWF0Y2gsIG9mZnNldCwgc3RyKSA9PiB7XG4gICAgICAgIGxldCBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBjdXJyID0gb2Zmc2V0O1xuICAgICAgICB3aGlsZSAoLS1jdXJyID49IDAgJiYgc3RyW2N1cnJdID09PSAnXFxcXCcpXG4gICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgICAgICAvLyBvZGQgbnVtYmVyIG9mIHNsYXNoZXMgbWVhbnMgfCBpcyBlc2NhcGVkXG4gICAgICAgICAgICAvLyBzbyB3ZSBsZWF2ZSBpdCBhbG9uZVxuICAgICAgICAgICAgcmV0dXJuICd8JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFkZCBzcGFjZSBiZWZvcmUgdW5lc2NhcGVkIHxcbiAgICAgICAgICAgIHJldHVybiAnIHwnO1xuICAgICAgICB9XG4gICAgfSksIGNlbGxzID0gcm93LnNwbGl0KC8gXFx8Lyk7XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEZpcnN0L2xhc3QgY2VsbCBpbiBhIHJvdyBjYW5ub3QgYmUgZW1wdHkgaWYgaXQgaGFzIG5vIGxlYWRpbmcvdHJhaWxpbmcgcGlwZVxuICAgIGlmICghY2VsbHNbMF0udHJpbSgpKSB7XG4gICAgICAgIGNlbGxzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmIChjZWxscy5sZW5ndGggPiAwICYmICFjZWxsc1tjZWxscy5sZW5ndGggLSAxXS50cmltKCkpIHtcbiAgICAgICAgY2VsbHMucG9wKCk7XG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgICBpZiAoY2VsbHMubGVuZ3RoID4gY291bnQpIHtcbiAgICAgICAgICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoY2VsbHMubGVuZ3RoIDwgY291bnQpXG4gICAgICAgICAgICAgICAgY2VsbHMucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgaXMgaWdub3JlZCBwZXIgdGhlIGdmbSBzcGVjXG4gICAgICAgIGNlbGxzW2ldID0gY2VsbHNbaV0udHJpbSgpLnJlcGxhY2UoL1xcXFxcXHwvZywgJ3wnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGxzO1xufVxuLyoqXG4gKiBSZW1vdmUgdHJhaWxpbmcgJ2Mncy4gRXF1aXZhbGVudCB0byBzdHIucmVwbGFjZSgvYyokLywgJycpLlxuICogL2MqJC8gaXMgdnVsbmVyYWJsZSB0byBSRURPUy5cbiAqXG4gKiBAcGFyYW0gc3RyXG4gKiBAcGFyYW0gY1xuICogQHBhcmFtIGludmVydCBSZW1vdmUgc3VmZml4IG9mIG5vbi1jIGNoYXJzIGluc3RlYWQuIERlZmF1bHQgZmFsc2V5LlxuICovXG5mdW5jdGlvbiBydHJpbShzdHIsIGMsIGludmVydCkge1xuICAgIGNvbnN0IGwgPSBzdHIubGVuZ3RoO1xuICAgIGlmIChsID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgLy8gTGVuZ3RoIG9mIHN1ZmZpeCBtYXRjaGluZyB0aGUgaW52ZXJ0IGNvbmRpdGlvbi5cbiAgICBsZXQgc3VmZkxlbiA9IDA7XG4gICAgLy8gU3RlcCBsZWZ0IHVudGlsIHdlIGZhaWwgdG8gbWF0Y2ggdGhlIGludmVydCBjb25kaXRpb24uXG4gICAgd2hpbGUgKHN1ZmZMZW4gPCBsKSB7XG4gICAgICAgIGNvbnN0IGN1cnJDaGFyID0gc3RyLmNoYXJBdChsIC0gc3VmZkxlbiAtIDEpO1xuICAgICAgICBpZiAoY3VyckNoYXIgPT09IGMgJiYgIWludmVydCkge1xuICAgICAgICAgICAgc3VmZkxlbisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJDaGFyICE9PSBjICYmIGludmVydCkge1xuICAgICAgICAgICAgc3VmZkxlbisrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zbGljZSgwLCBsIC0gc3VmZkxlbik7XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2luZ0JyYWNrZXQoc3RyLCBiKSB7XG4gICAgaWYgKHN0ci5pbmRleE9mKGJbMV0pID09PSAtMSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGxldCBsZXZlbCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cltpXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyW2ldID09PSBiWzBdKSB7XG4gICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0cltpXSA9PT0gYlsxXSkge1xuICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIG91dHB1dExpbmsoY2FwLCBsaW5rLCByYXcsIGxleGVyKSB7XG4gICAgY29uc3QgaHJlZiA9IGxpbmsuaHJlZjtcbiAgICBjb25zdCB0aXRsZSA9IGxpbmsudGl0bGUgPyBlc2NhcGUkMShsaW5rLnRpdGxlKSA6IG51bGw7XG4gICAgY29uc3QgdGV4dCA9IGNhcFsxXS5yZXBsYWNlKC9cXFxcKFtcXFtcXF1dKS9nLCAnJDEnKTtcbiAgICBpZiAoY2FwWzBdLmNoYXJBdCgwKSAhPT0gJyEnKSB7XG4gICAgICAgIGxleGVyLnN0YXRlLmluTGluayA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgIHRva2VuczogbGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpXG4gICAgICAgIH07XG4gICAgICAgIGxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgIHJhdyxcbiAgICAgICAgaHJlZixcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIHRleHQ6IGVzY2FwZSQxKHRleHQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCB0ZXh0KSB7XG4gICAgY29uc3QgbWF0Y2hJbmRlbnRUb0NvZGUgPSByYXcubWF0Y2goL14oXFxzKykoPzpgYGApLyk7XG4gICAgaWYgKG1hdGNoSW5kZW50VG9Db2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRUb0NvZGUgPSBtYXRjaEluZGVudFRvQ29kZVsxXTtcbiAgICByZXR1cm4gdGV4dFxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoSW5kZW50SW5Ob2RlID0gbm9kZS5tYXRjaCgvXlxccysvKTtcbiAgICAgICAgaWYgKG1hdGNoSW5kZW50SW5Ob2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaW5kZW50SW5Ob2RlXSA9IG1hdGNoSW5kZW50SW5Ob2RlO1xuICAgICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zbGljZShpbmRlbnRUb0NvZGUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vKipcbiAqIFRva2VuaXplclxuICovXG5jbGFzcyBfVG9rZW5pemVyIHtcbiAgICBvcHRpb25zO1xuICAgIHJ1bGVzOyAvLyBzZXQgYnkgdGhlIGxleGVyXG4gICAgbGV4ZXI7IC8vIHNldCBieSB0aGUgbGV4ZXJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgIH1cbiAgICBzcGFjZShzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCAmJiBjYXBbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3BhY2UnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvZGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suY29kZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZScsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgY29kZUJsb2NrU3R5bGU6ICdpbmRlbnRlZCcsXG4gICAgICAgICAgICAgICAgdGV4dDogIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgICAgICAgICA/IHJ0cmltKHRleHQsICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICA6IHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmVuY2VzKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmZlbmNlcy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHJhdyA9IGNhcFswXTtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgY2FwWzNdIHx8ICcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICBsYW5nOiBjYXBbMl0gPyBjYXBbMl0udHJpbSgpLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sICckMScpIDogY2FwWzJdLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGVhZGluZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0udHJpbSgpO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nICNzXG4gICAgICAgICAgICBpZiAoLyMkLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHJ0cmltKHRleHQsICcjJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0cmltbWVkIHx8IC8gJC8udGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21tb25NYXJrIHJlcXVpcmVzIHNwYWNlIGJlZm9yZSB0cmFpbGluZyAjc1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdHJpbW1lZC50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhyKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmhyLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHInLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGJsb2NrcXVvdGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suYmxvY2txdW90ZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBydHJpbShjYXBbMF0ucmVwbGFjZSgvXiAqPlsgXFx0XT8vZ20sICcnKSwgJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5sZXhlci5zdGF0ZS50b3A7XG4gICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmxleGVyLmJsb2NrVG9rZW5zKHRleHQpO1xuICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSB0b3A7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaXN0KHNyYykge1xuICAgICAgICBsZXQgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5saXN0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IGJ1bGwgPSBjYXBbMV0udHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgaXNvcmRlcmVkID0gYnVsbC5sZW5ndGggPiAxO1xuICAgICAgICAgICAgY29uc3QgbGlzdCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgICAgICAgcmF3OiAnJyxcbiAgICAgICAgICAgICAgICBvcmRlcmVkOiBpc29yZGVyZWQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGlzb3JkZXJlZCA/ICtidWxsLnNsaWNlKDAsIC0xKSA6ICcnLFxuICAgICAgICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBidWxsID0gaXNvcmRlcmVkID8gYFxcXFxkezEsOX1cXFxcJHtidWxsLnNsaWNlKC0xKX1gIDogYFxcXFwke2J1bGx9YDtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICBidWxsID0gaXNvcmRlcmVkID8gYnVsbCA6ICdbKistXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgbmV4dCBsaXN0IGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IGl0ZW1SZWdleCA9IG5ldyBSZWdFeHAoYF4oIHswLDN9JHtidWxsfSkoKD86W1xcdCBdW15cXFxcbl0qKT8oPzpcXFxcbnwkKSlgKTtcbiAgICAgICAgICAgIGxldCByYXcgPSAnJztcbiAgICAgICAgICAgIGxldCBpdGVtQ29udGVudHMgPSAnJztcbiAgICAgICAgICAgIGxldCBlbmRzV2l0aEJsYW5rTGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgY3VycmVudCBidWxsZXQgcG9pbnQgY2FuIHN0YXJ0IGEgbmV3IExpc3QgSXRlbVxuICAgICAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgICAgIGxldCBlbmRFYXJseSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghKGNhcCA9IGl0ZW1SZWdleC5leGVjKHNyYykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ydWxlcy5ibG9jay5oci50ZXN0KHNyYykpIHsgLy8gRW5kIGxpc3QgaWYgYnVsbGV0IHdhcyBhY3R1YWxseSBIUiAocG9zc2libHkgbW92ZSBpbnRvIGl0ZW1SZWdleD8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByYXcgPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhyYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluZSA9IGNhcFsyXS5zcGxpdCgnXFxuJywgMSlbMF0ucmVwbGFjZSgvXlxcdCsvLCAodCkgPT4gJyAnLnJlcGVhdCgzICogdC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dExpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gbGluZS50cmltU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IGNhcFsyXS5zZWFyY2goL1teIF0vKTsgLy8gRmluZCBmaXJzdCBub24tc3BhY2UgY2hhclxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSBpbmRlbnQgPiA0ID8gMSA6IGluZGVudDsgLy8gVHJlYXQgaW5kZW50ZWQgY29kZSBibG9ja3MgKD4gNCBzcGFjZXMpIGFzIGhhdmluZyBvbmx5IDEgaW5kZW50XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IGNhcFsxXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBibGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmUgJiYgL14gKiQvLnRlc3QobmV4dExpbmUpKSB7IC8vIEl0ZW1zIGJlZ2luIHdpdGggYXQgbW9zdCBvbmUgYmxhbmsgbGluZVxuICAgICAgICAgICAgICAgICAgICByYXcgKz0gbmV4dExpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhuZXh0TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kRWFybHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVuZEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRCdWxsZXRSZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19KD86WyorLV18XFxcXGR7MSw5fVsuKV0pKCg/OlsgXFx0XVteXFxcXG5dKik/KD86XFxcXG58JCkpYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhyUmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSgoPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlbmNlc0JlZ2luUmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlxcYFxcYFxcYHx+fn4pYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdCZWdpblJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0jYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvbGxvd2luZyBsaW5lcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gTGlzdCBJdGVtXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd0xpbmUgPSBzcmMuc3BsaXQoJ1xcbicsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dExpbmUgPSByYXdMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmUtYWxpZ24gdG8gZm9sbG93IGNvbW1vbm1hcmsgbmVzdGluZyBydWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gbmV4dExpbmUucmVwbGFjZSgvXiB7MSw0fSg/PSggezR9KSpbXiBdKS9nLCAnICAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgY29kZSBmZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZW5jZXNCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBoZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGluZ0JlZ2luUmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuZCBsaXN0IGl0ZW0gaWYgZm91bmQgc3RhcnQgb2YgbmV3IGJ1bGxldFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRCdWxsZXRSZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBydWxlIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KHNyYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TGluZS5zZWFyY2goL1teIF0vKSA+PSBpbmRlbnQgfHwgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBEZWRlbnQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgKz0gJ1xcbicgKyBuZXh0TGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90IGVub3VnaCBpbmRlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibGFua0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmFncmFwaCBjb250aW51YXRpb24gdW5sZXNzIGxhc3QgbGluZSB3YXMgYSBkaWZmZXJlbnQgYmxvY2sgbGV2ZWwgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnNlYXJjaCgvW14gXS8pID49IDQpIHsgLy8gaW5kZW50ZWQgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlbmNlc0JlZ2luUmVnZXgudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoclJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyArPSAnXFxuJyArIG5leHRMaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFibGFua0xpbmUgJiYgIW5leHRMaW5lLnRyaW0oKSkgeyAvLyBDaGVjayBpZiBjdXJyZW50IGxpbmUgaXMgYmxhbmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3ICs9IHJhd0xpbmUgKyAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3TGluZS5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBuZXh0TGluZS5zbGljZShpbmRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbGlzdC5sb29zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgaXRlbSBlbmRlZCB3aXRoIGEgYmxhbmsgbGluZSwgdGhlIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoQmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0Lmxvb3NlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXFxuICpcXG4gKiQvLnRlc3QocmF3KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kc1dpdGhCbGFua0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpc3Rhc2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBpc2NoZWNrZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHRhc2sgbGlzdCBpdGVtc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzdGFzayA9IC9eXFxbWyB4WF1cXF0gLy5leGVjKGl0ZW1Db250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc3Rhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzY2hlY2tlZCA9IGlzdGFza1swXSAhPT0gJ1sgXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzID0gaXRlbUNvbnRlbnRzLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW0nLFxuICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgIHRhc2s6ICEhaXN0YXNrLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBpc2NoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgIGxvb3NlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogaXRlbUNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGlzdC5yYXcgKz0gcmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IGNvbnN1bWUgbmV3bGluZXMgYXQgZW5kIG9mIGZpbmFsIGl0ZW0uIEFsdGVybmF0aXZlbHksIG1ha2UgaXRlbVJlZ2V4ICpzdGFydCogd2l0aCBhbnkgbmV3bGluZXMgdG8gc2ltcGxpZnkvc3BlZWQgdXAgZW5kc1dpdGhCbGFua0xpbmUgbG9naWNcbiAgICAgICAgICAgIGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXS5yYXcgPSByYXcudHJpbUVuZCgpO1xuICAgICAgICAgICAgKGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXSkudGV4dCA9IGl0ZW1Db250ZW50cy50cmltRW5kKCk7XG4gICAgICAgICAgICBsaXN0LnJhdyA9IGxpc3QucmF3LnRyaW1FbmQoKTtcbiAgICAgICAgICAgIC8vIEl0ZW0gY2hpbGQgdG9rZW5zIGhhbmRsZWQgaGVyZSBhdCBlbmQgYmVjYXVzZSB3ZSBuZWVkZWQgdG8gaGF2ZSB0aGUgZmluYWwgaXRlbSB0byB0cmltIGl0IGZpcnN0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLnRvcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxpc3QuaXRlbXNbaV0udG9rZW5zID0gdGhpcy5sZXhlci5ibG9ja1Rva2VucyhsaXN0Lml0ZW1zW2ldLnRleHQsIFtdKTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpc3QubG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbGlzdCBzaG91bGQgYmUgbG9vc2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhY2VycyA9IGxpc3QuaXRlbXNbaV0udG9rZW5zLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gJ3NwYWNlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc011bHRpcGxlTGluZUJyZWFrcyA9IHNwYWNlcnMubGVuZ3RoID4gMCAmJiBzcGFjZXJzLnNvbWUodCA9PiAvXFxuLipcXG4vLnRlc3QodC5yYXcpKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5sb29zZSA9IGhhc011bHRpcGxlTGluZUJyZWFrcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgYWxsIGl0ZW1zIHRvIGxvb3NlIGlmIGxpc3QgaXMgbG9vc2VcbiAgICAgICAgICAgIGlmIChsaXN0Lmxvb3NlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuaXRlbXNbaV0ubG9vc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGh0bWwoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaHRtbC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdodG1sJyxcbiAgICAgICAgICAgICAgICBibG9jazogdHJ1ZSxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBwcmU6IGNhcFsxXSA9PT0gJ3ByZScgfHwgY2FwWzFdID09PSAnc2NyaXB0JyB8fCBjYXBbMV0gPT09ICdzdHlsZScsXG4gICAgICAgICAgICAgICAgdGV4dDogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlZihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5kZWYuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBjYXBbMV0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICAgICAgICBjb25zdCBocmVmID0gY2FwWzJdID8gY2FwWzJdLnJlcGxhY2UoL148KC4qKT4kLywgJyQxJykucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnN1YnN0cmluZygxLCBjYXBbM10ubGVuZ3RoIC0gMSkucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiBjYXBbM107XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkZWYnLFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHRpdGxlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhYmxlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRhYmxlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKCFjYXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIS9bOnxdLy50ZXN0KGNhcFsyXSkpIHtcbiAgICAgICAgICAgIC8vIGRlbGltaXRlciByb3cgbXVzdCBoYXZlIGEgcGlwZSAofCkgb3IgY29sb24gKDopIG90aGVyd2lzZSBpdCBpcyBhIHNldGV4dCBoZWFkaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHNwbGl0Q2VsbHMoY2FwWzFdKTtcbiAgICAgICAgY29uc3QgYWxpZ25zID0gY2FwWzJdLnJlcGxhY2UoL15cXHx8XFx8ICokL2csICcnKS5zcGxpdCgnfCcpO1xuICAgICAgICBjb25zdCByb3dzID0gY2FwWzNdICYmIGNhcFszXS50cmltKCkgPyBjYXBbM10ucmVwbGFjZSgvXFxuWyBcXHRdKiQvLCAnJykuc3BsaXQoJ1xcbicpIDogW107XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICBoZWFkZXI6IFtdLFxuICAgICAgICAgICAgYWxpZ246IFtdLFxuICAgICAgICAgICAgcm93czogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoICE9PSBhbGlnbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBoZWFkZXIgYW5kIGFsaWduIGNvbHVtbnMgbXVzdCBiZSBlcXVhbCwgcm93cyBjYW4gYmUgZGlmZmVyZW50LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgYWxpZ24gb2YgYWxpZ25zKSB7XG4gICAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFsaWduLnB1c2goJ3JpZ2h0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFsaWduLnB1c2goJ2NlbnRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmFsaWduLnB1c2goJ2xlZnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ24ucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpdGVtLmhlYWRlci5wdXNoKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBoZWFkZXIsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShoZWFkZXIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICBpdGVtLnJvd3MucHVzaChzcGxpdENlbGxzKHJvdywgaXRlbS5oZWFkZXIubGVuZ3RoKS5tYXAoY2VsbCA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogY2VsbCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZShjZWxsKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIGxoZWFkaW5nKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsyXS5jaGFyQXQoMCkgPT09ICc9JyA/IDEgOiAyLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFsxXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFsxXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYWdyYXBoKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnBhcmFncmFwaC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbidcbiAgICAgICAgICAgICAgICA/IGNhcFsxXS5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgICAgICA6IGNhcFsxXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRleHQoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGV4dC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFswXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXNjYXBlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGVzY2FwZSQxKGNhcFsxXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFnKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50YWcuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluTGluayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgJiYgL148KHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgJiYgL148XFwvKHByZXxjb2RlfGtiZHxzY3JpcHQpKFxcc3w+KS9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHRtbCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgaW5MaW5rOiB0aGlzLmxleGVyLnN0YXRlLmluTGluayxcbiAgICAgICAgICAgICAgICBpblJhd0Jsb2NrOiB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2ssXG4gICAgICAgICAgICAgICAgYmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaW5rKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wZWRhbnRpYyAmJiAvXjwvLnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21tb25tYXJrIHJlcXVpcmVzIG1hdGNoaW5nIGFuZ2xlIGJyYWNrZXRzXG4gICAgICAgICAgICAgICAgaWYgKCEoLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuZGluZyBhbmdsZSBicmFja2V0IGNhbm5vdCBiZSBlc2NhcGVkXG4gICAgICAgICAgICAgICAgY29uc3QgcnRyaW1TbGFzaCA9IHJ0cmltKHRyaW1tZWRVcmwuc2xpY2UoMCwgLTEpLCAnXFxcXCcpO1xuICAgICAgICAgICAgICAgIGlmICgodHJpbW1lZFVybC5sZW5ndGggLSBydHJpbVNsYXNoLmxlbmd0aCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGFyZW5JbmRleCA9IGZpbmRDbG9zaW5nQnJhY2tldChjYXBbMl0sICcoKScpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyZW5JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gY2FwWzBdLmluZGV4T2YoJyEnKSA9PT0gMCA/IDUgOiA0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGNhcFsyXSA9IGNhcFsyXS5zdWJzdHJpbmcoMCwgbGFzdFBhcmVuSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjYXBbMF0gPSBjYXBbMF0uc3Vic3RyaW5nKDAsIGxpbmtMZW4pLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGhyZWYgPSBjYXBbMl07XG4gICAgICAgICAgICBsZXQgdGl0bGUgPSAnJztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGxpdCBwZWRhbnRpYyBocmVmIGFuZCB0aXRsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmsgPSAvXihbXidcIl0qW15cXHNdKVxccysoWydcIl0pKC4qKVxcMi8uZXhlYyhocmVmKTtcbiAgICAgICAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gbGlua1sxXTtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUgPSBsaW5rWzNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaHJlZiA9IGhyZWYudHJpbSgpO1xuICAgICAgICAgICAgaWYgKC9ePC8udGVzdChocmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgISgvPiQvLnRlc3QodHJpbW1lZFVybCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBlZGFudGljIGFsbG93cyBzdGFydGluZyBhbmdsZSBicmFja2V0IHdpdGhvdXQgZW5kaW5nIGFuZ2xlIGJyYWNrZXRcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgICAgICAgICAgaHJlZjogaHJlZiA/IGhyZWYucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5hbnlQdW5jdHVhdGlvbiwgJyQxJykgOiBocmVmLFxuICAgICAgICAgICAgICAgIHRpdGxlOiB0aXRsZSA/IHRpdGxlLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24sICckMScpIDogdGl0bGVcbiAgICAgICAgICAgIH0sIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmbGluayhzcmMsIGxpbmtzKSB7XG4gICAgICAgIGxldCBjYXA7XG4gICAgICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpXG4gICAgICAgICAgICB8fCAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtTdHJpbmcgPSAoY2FwWzJdIHx8IGNhcFsxXSkucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgICAgICAgICAgY29uc3QgbGluayA9IGxpbmtzW2xpbmtTdHJpbmcudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0TGluayhjYXAsIGxpbmssIGNhcFswXSwgdGhpcy5sZXhlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyID0gJycpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmdMRGVsaW0uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBfIGNhbid0IGJlIGJldHdlZW4gdHdvIGFscGhhbnVtZXJpY3MuIFxccHtMfVxccHtOfSBpbmNsdWRlcyBub24tZW5nbGlzaCBhbHBoYWJldC9udW1iZXJzIGFzIHdlbGxcbiAgICAgICAgaWYgKG1hdGNoWzNdICYmIHByZXZDaGFyLm1hdGNoKC9bXFxwe0x9XFxwe059XS91KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbmV4dENoYXIgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCAnJztcbiAgICAgICAgaWYgKCFuZXh0Q2hhciB8fCAhcHJldkNoYXIgfHwgdGhpcy5ydWxlcy5pbmxpbmUucHVuY3R1YXRpb24uZXhlYyhwcmV2Q2hhcikpIHtcbiAgICAgICAgICAgIC8vIHVuaWNvZGUgUmVnZXggY291bnRzIGVtb2ppIGFzIDEgY2hhcjsgc3ByZWFkIGludG8gYXJyYXkgZm9yIHByb3BlciBjb3VudCAodXNlZCBtdWx0aXBsZSB0aW1lcyBiZWxvdylcbiAgICAgICAgICAgIGNvbnN0IGxMZW5ndGggPSBbLi4ubWF0Y2hbMF1dLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgckRlbGltLCByTGVuZ3RoLCBkZWxpbVRvdGFsID0gbExlbmd0aCwgbWlkRGVsaW1Ub3RhbCA9IDA7XG4gICAgICAgICAgICBjb25zdCBlbmRSZWcgPSBtYXRjaFswXVswXSA9PT0gJyonID8gdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmdSRGVsaW1Bc3QgOiB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZ1JEZWxpbVVuZDtcbiAgICAgICAgICAgIGVuZFJlZy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgLy8gQ2xpcCBtYXNrZWRTcmMgdG8gc2FtZSBzZWN0aW9uIG9mIHN0cmluZyBhcyBzcmMgKG1vdmUgdG8gbGV4ZXI/KVxuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKC0xICogc3JjLmxlbmd0aCArIGxMZW5ndGgpO1xuICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IGVuZFJlZy5leGVjKG1hc2tlZFNyYykpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByRGVsaW0gPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBtYXRjaFs2XTtcbiAgICAgICAgICAgICAgICBpZiAoIXJEZWxpbSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgc2luZ2xlICogaW4gX19hYmMqYWJjX19cbiAgICAgICAgICAgICAgICByTGVuZ3RoID0gWy4uLnJEZWxpbV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFszXSB8fCBtYXRjaFs0XSkgeyAvLyBmb3VuZCBhbm90aGVyIExlZnQgRGVsaW1cbiAgICAgICAgICAgICAgICAgICAgZGVsaW1Ub3RhbCArPSByTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hbNV0gfHwgbWF0Y2hbNl0pIHsgLy8gZWl0aGVyIExlZnQgb3IgUmlnaHQgRGVsaW1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxMZW5ndGggJSAzICYmICEoKGxMZW5ndGggKyByTGVuZ3RoKSAlIDMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaWREZWxpbVRvdGFsICs9IHJMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gQ29tbW9uTWFyayBFbXBoYXNpcyBSdWxlcyA5LTEwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsaW1Ub3RhbCAtPSByTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChkZWxpbVRvdGFsID4gMClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIEhhdmVuJ3QgZm91bmQgZW5vdWdoIGNsb3NpbmcgZGVsaW1pdGVyc1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBleHRyYSBjaGFyYWN0ZXJzLiAqYSoqKiAtPiAqYSpcbiAgICAgICAgICAgICAgICByTGVuZ3RoID0gTWF0aC5taW4ockxlbmd0aCwgckxlbmd0aCArIGRlbGltVG90YWwgKyBtaWREZWxpbVRvdGFsKTtcbiAgICAgICAgICAgICAgICAvLyBjaGFyIGxlbmd0aCBjYW4gYmUgPjEgZm9yIHVuaWNvZGUgY2hhcmFjdGVycztcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q2hhckxlbmd0aCA9IFsuLi5tYXRjaFswXV1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdyA9IHNyYy5zbGljZSgwLCBsTGVuZ3RoICsgbWF0Y2guaW5kZXggKyBsYXN0Q2hhckxlbmd0aCArIHJMZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBgZW1gIGlmIHNtYWxsZXN0IGRlbGltaXRlciBoYXMgb2RkIGNoYXIgY291bnQuICphKioqXG4gICAgICAgICAgICAgICAgaWYgKE1hdGgubWluKGxMZW5ndGgsIHJMZW5ndGgpICUgMikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gcmF3LnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2Vucyh0ZXh0KVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgJ3N0cm9uZycgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBldmVuIGNoYXIgY291bnQuICoqYSoqKlxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSByYXcuc2xpY2UoMiwgLTIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuczogdGhpcy5sZXhlci5pbmxpbmVUb2tlbnModGV4dClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvZGVzcGFuKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5jb2RlLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQgPSBjYXBbMl0ucmVwbGFjZSgvXFxuL2csICcgJyk7XG4gICAgICAgICAgICBjb25zdCBoYXNOb25TcGFjZUNoYXJzID0gL1teIF0vLnRlc3QodGV4dCk7XG4gICAgICAgICAgICBjb25zdCBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcyA9IC9eIC8udGVzdCh0ZXh0KSAmJiAvICQvLnRlc3QodGV4dCk7XG4gICAgICAgICAgICBpZiAoaGFzTm9uU3BhY2VDaGFycyAmJiBoYXNTcGFjZUNoYXJzT25Cb3RoRW5kcykge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSQxKHRleHQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZXNwYW4nLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnIoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmJyLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnInLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZGVsLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVsJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMl0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2VucyhjYXBbMl0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGF1dG9saW5rKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0LCBocmVmO1xuICAgICAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSQxKGNhcFsxXSk7XG4gICAgICAgICAgICAgICAgaHJlZiA9ICdtYWlsdG86JyArIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZXNjYXBlJDEoY2FwWzFdKTtcbiAgICAgICAgICAgICAgICBocmVmID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0b2tlbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmwoc3JjKSB7XG4gICAgICAgIGxldCBjYXA7XG4gICAgICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS51cmwuZXhlYyhzcmMpKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCwgaHJlZjtcbiAgICAgICAgICAgIGlmIChjYXBbMl0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUkMShjYXBbMF0pO1xuICAgICAgICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gZXh0ZW5kZWQgYXV0b2xpbmsgcGF0aCB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgbGV0IHByZXZDYXBaZXJvO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldkNhcFplcm8gPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgICAgIGNhcFswXSA9IHRoaXMucnVsZXMuaW5saW5lLl9iYWNrcGVkYWwuZXhlYyhjYXBbMF0pPy5bMF0gPz8gJyc7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZSQxKGNhcFswXSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSAnaHR0cDovLycgKyBjYXBbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBocmVmID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmsnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgaHJlZixcbiAgICAgICAgICAgICAgICB0b2tlbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbmxpbmVUZXh0KHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50ZXh0LmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgbGV0IHRleHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGNhcFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUkMShjYXBbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBCbG9jay1MZXZlbCBHcmFtbWFyXG4gKi9cbmNvbnN0IG5ld2xpbmUgPSAvXig/OiAqKD86XFxufCQpKSsvO1xuY29uc3QgYmxvY2tDb2RlID0gL14oIHs0fVteXFxuXSsoPzpcXG4oPzogKig/OlxcbnwkKSkqKT8pKy87XG5jb25zdCBmZW5jZXMgPSAvXiB7MCwzfShgezMsfSg/PVteYFxcbl0qKD86XFxufCQpKXx+ezMsfSkoW15cXG5dKikoPzpcXG58JCkoPzp8KFtcXHNcXFNdKj8pKD86XFxufCQpKSg/OiB7MCwzfVxcMVt+YF0qICooPz1cXG58JCl8JCkvO1xuY29uc3QgaHIgPSAvXiB7MCwzfSgoPzotW1xcdCBdKil7Myx9fCg/Ol9bIFxcdF0qKXszLH18KD86XFwqWyBcXHRdKil7Myx9KSg/Olxcbit8JCkvO1xuY29uc3QgaGVhZGluZyA9IC9eIHswLDN9KCN7MSw2fSkoPz1cXHN8JCkoLiopKD86XFxuK3wkKS87XG5jb25zdCBidWxsZXQgPSAvKD86WyorLV18XFxkezEsOX1bLildKS87XG5jb25zdCBsaGVhZGluZyA9IGVkaXQoL14oPyFidWxsICkoKD86LnxcXG4oPyFcXHMqP1xcbnxidWxsICkpKz8pXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8pXG4gICAgLnJlcGxhY2UoL2J1bGwvZywgYnVsbGV0KSAvLyBsaXN0cyBjYW4gaW50ZXJydXB0XG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfcGFyYWdyYXBoID0gL14oW15cXG5dKyg/Olxcbig/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXxmZW5jZXN8bGlzdHxodG1sfHRhYmxlfCArXFxuKVteXFxuXSspKikvO1xuY29uc3QgYmxvY2tUZXh0ID0gL15bXlxcbl0rLztcbmNvbnN0IF9ibG9ja0xhYmVsID0gLyg/IVxccypcXF0pKD86XFxcXC58W15cXFtcXF1cXFxcXSkrLztcbmNvbnN0IGRlZiA9IGVkaXQoL14gezAsM31cXFsobGFiZWwpXFxdOiAqKD86XFxuICopPyhbXjxcXHNdW15cXHNdKnw8Lio/PikoPzooPzogKyg/OlxcbiAqKT98ICpcXG4gKikodGl0bGUpKT8gKig/Olxcbit8JCkvKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9ibG9ja0xhYmVsKVxuICAgIC5yZXBsYWNlKCd0aXRsZScsIC8oPzpcIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnW14nXFxuXSooPzpcXG5bXidcXG5dKykqXFxuPyd8XFwoW14oKV0qXFwpKS8pXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBsaXN0ID0gZWRpdCgvXiggezAsM31idWxsKShbIFxcdF1bXlxcbl0rPyk/KD86XFxufCQpLylcbiAgICAucmVwbGFjZSgvYnVsbC9nLCBidWxsZXQpXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBfdGFnID0gJ2FkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9uJ1xuICAgICsgJ3xjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbidcbiAgICArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZSdcbiAgICArICd8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG1ldGF8bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbidcbiAgICArICd8cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyJ1xuICAgICsgJ3x0cmFja3x1bCc7XG5jb25zdCBfY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuY29uc3QgaHRtbCA9IGVkaXQoJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgKyAnPChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKVtcXFxccz5dW1xcXFxzXFxcXFNdKj8oPzo8L1xcXFwxPlteXFxcXG5dKlxcXFxuK3wkKScgLy8gKDEpXG4gICAgKyAnfGNvbW1lbnRbXlxcXFxuXSooXFxcXG4rfCQpJyAvLyAoMilcbiAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICsgJ3w8IVtBLVpdW1xcXFxzXFxcXFNdKj8oPzo+XFxcXG4qfCQpJyAvLyAoNClcbiAgICArICd8PCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qPyg/OlxcXFxdXFxcXF0+XFxcXG4qfCQpJyAvLyAoNSlcbiAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDYpXG4gICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86KD86XFxcXG4gKikrXFxcXG58JCknIC8vICg3KSBvcGVuIHRhZ1xuICAgICsgJ3w8Lyg/IXNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWEpW2Etel1bXFxcXHctXSpcXFxccyo+KD89WyBcXFxcdF0qKD86XFxcXG58JCkpW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDcpIGNsb3NpbmcgdGFnXG4gICAgKyAnKScsICdpJylcbiAgICAucmVwbGFjZSgnY29tbWVudCcsIF9jb21tZW50KVxuICAgIC5yZXBsYWNlKCd0YWcnLCBfdGFnKVxuICAgIC5yZXBsYWNlKCdhdHRyaWJ1dGUnLCAvICtbYS16QS1aOl9dW1xcdy46LV0qKD86ICo9ICpcIlteXCJcXG5dKlwifCAqPSAqJ1teJ1xcbl0qJ3wgKj0gKlteXFxzXCInPTw+YF0rKT8vKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgcGFyYWdyYXBoID0gZWRpdChfcGFyYWdyYXBoKVxuICAgIC5yZXBsYWNlKCdocicsIGhyKVxuICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSg/OlxcXFxzfCQpJylcbiAgICAucmVwbGFjZSgnfGxoZWFkaW5nJywgJycpIC8vIHNldGV4IGhlYWRpbmdzIGRvbid0IGludGVycnVwdCBjb21tb25tYXJrIHBhcmFncmFwaHNcbiAgICAucmVwbGFjZSgnfHRhYmxlJywgJycpXG4gICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAgIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gICAgLnJlcGxhY2UoJ3RhZycsIF90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBibG9ja3F1b3RlID0gZWRpdCgvXiggezAsM30+ID8ocGFyYWdyYXBofFteXFxuXSopKD86XFxufCQpKSsvKVxuICAgIC5yZXBsYWNlKCdwYXJhZ3JhcGgnLCBwYXJhZ3JhcGgpXG4gICAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gKi9cbmNvbnN0IGJsb2NrTm9ybWFsID0ge1xuICAgIGJsb2NrcXVvdGUsXG4gICAgY29kZTogYmxvY2tDb2RlLFxuICAgIGRlZixcbiAgICBmZW5jZXMsXG4gICAgaGVhZGluZyxcbiAgICBocixcbiAgICBodG1sLFxuICAgIGxoZWFkaW5nLFxuICAgIGxpc3QsXG4gICAgbmV3bGluZSxcbiAgICBwYXJhZ3JhcGgsXG4gICAgdGFibGU6IG5vb3BUZXN0LFxuICAgIHRleHQ6IGJsb2NrVGV4dFxufTtcbi8qKlxuICogR0ZNIEJsb2NrIEdyYW1tYXJcbiAqL1xuY29uc3QgZ2ZtVGFibGUgPSBlZGl0KCdeICooW15cXFxcbiBdLiopXFxcXG4nIC8vIEhlYWRlclxuICAgICsgJyB7MCwzfSgoPzpcXFxcfCAqKT86Py0rOj8gKig/OlxcXFx8ICo6Py0rOj8gKikqKD86XFxcXHwgKik/KScgLy8gQWxpZ25cbiAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScpIC8vIENlbGxzXG4gICAgLnJlcGxhY2UoJ2hyJywgaHIpXG4gICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9KD86XFxcXHN8JCknKVxuICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgIC5yZXBsYWNlKCdjb2RlJywgJyB7NH1bXlxcXFxuXScpXG4gICAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAgIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gICAgLnJlcGxhY2UoJ3RhZycsIF90YWcpIC8vIHRhYmxlcyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGJsb2NrR2ZtID0ge1xuICAgIC4uLmJsb2NrTm9ybWFsLFxuICAgIHRhYmxlOiBnZm1UYWJsZSxcbiAgICBwYXJhZ3JhcGg6IGVkaXQoX3BhcmFncmFwaClcbiAgICAgICAgLnJlcGxhY2UoJ2hyJywgaHIpXG4gICAgICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSg/OlxcXFxzfCQpJylcbiAgICAgICAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gICAgICAgIC5yZXBsYWNlKCd0YWJsZScsIGdmbVRhYmxlKSAvLyBpbnRlcnJ1cHQgcGFyYWdyYXBocyB3aXRoIHRhYmxlXG4gICAgICAgIC5yZXBsYWNlKCdibG9ja3F1b3RlJywgJyB7MCwzfT4nKVxuICAgICAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gICAgICAgIC5yZXBsYWNlKCdodG1sJywgJzwvPyg/OnRhZykoPzogK3xcXFxcbnwvPz4pfDwoPzpzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhfCEtLSknKVxuICAgICAgICAucmVwbGFjZSgndGFnJywgX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgICAgICAgLmdldFJlZ2V4KClcbn07XG4vKipcbiAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAqL1xuY29uc3QgYmxvY2tQZWRhbnRpYyA9IHtcbiAgICAuLi5ibG9ja05vcm1hbCxcbiAgICBodG1sOiBlZGl0KCdeICooPzpjb21tZW50ICooPzpcXFxcbnxcXFxccyokKSdcbiAgICAgICAgKyAnfDwodGFnKVtcXFxcc1xcXFxTXSs/PC9cXFxcMT4gKig/OlxcXFxuezIsfXxcXFxccyokKScgLy8gY2xvc2VkIHRhZ1xuICAgICAgICArICd8PHRhZyg/OlwiW15cIl0qXCJ8XFwnW15cXCddKlxcJ3xcXFxcc1teXFwnXCIvPlxcXFxzXSopKj8vPz4gKig/OlxcXFxuezIsfXxcXFxccyokKSknKVxuICAgICAgICAucmVwbGFjZSgnY29tbWVudCcsIF9jb21tZW50KVxuICAgICAgICAucmVwbGFjZSgvdGFnL2csICcoPyEoPzonXG4gICAgICAgICsgJ2F8ZW18c3Ryb25nfHNtYWxsfHN8Y2l0ZXxxfGRmbnxhYmJyfGRhdGF8dGltZXxjb2RlfHZhcnxzYW1wfGtiZHxzdWInXG4gICAgICAgICsgJ3xzdXB8aXxifHV8bWFya3xydWJ5fHJ0fHJwfGJkaXxiZG98c3Bhbnxicnx3YnJ8aW5zfGRlbHxpbWcpJ1xuICAgICAgICArICdcXFxcYilcXFxcdysoPyE6fFteXFxcXHdcXFxcc0BdKkApXFxcXGInKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICBkZWY6IC9eICpcXFsoW15cXF1dKylcXF06ICo8PyhbXlxccz5dKyk+Pyg/OiArKFtcIihdW15cXG5dK1tcIildKSk/ICooPzpcXG4rfCQpLyxcbiAgICBoZWFkaW5nOiAvXigjezEsNn0pKC4qKSg/Olxcbit8JCkvLFxuICAgIGZlbmNlczogbm9vcFRlc3QsIC8vIGZlbmNlcyBub3Qgc3VwcG9ydGVkXG4gICAgbGhlYWRpbmc6IC9eKC4rPylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgICBwYXJhZ3JhcGg6IGVkaXQoX3BhcmFncmFwaClcbiAgICAgICAgLnJlcGxhY2UoJ2hyJywgaHIpXG4gICAgICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyAqI3sxLDZ9ICpbXlxcbl0nKVxuICAgICAgICAucmVwbGFjZSgnbGhlYWRpbmcnLCBsaGVhZGluZylcbiAgICAgICAgLnJlcGxhY2UoJ3x0YWJsZScsICcnKVxuICAgICAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAgICAgLnJlcGxhY2UoJ3xmZW5jZXMnLCAnJylcbiAgICAgICAgLnJlcGxhY2UoJ3xsaXN0JywgJycpXG4gICAgICAgIC5yZXBsYWNlKCd8aHRtbCcsICcnKVxuICAgICAgICAucmVwbGFjZSgnfHRhZycsICcnKVxuICAgICAgICAuZ2V0UmVnZXgoKVxufTtcbi8qKlxuICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAqL1xuY29uc3QgZXNjYXBlID0gL15cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS87XG5jb25zdCBpbmxpbmVDb2RlID0gL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLztcbmNvbnN0IGJyID0gL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvO1xuY29uc3QgaW5saW5lVGV4dCA9IC9eKGArfFteYF0pKD86KD89IHsyLH1cXG4pfFtcXHNcXFNdKj8oPzooPz1bXFxcXDwhXFxbYCpfXXxcXGJffCQpfFteIF0oPz0gezIsfVxcbikpKS87XG4vLyBsaXN0IG9mIHVuaWNvZGUgcHVuY3R1YXRpb24gbWFya3MsIHBsdXMgYW55IG1pc3NpbmcgY2hhcmFjdGVycyBmcm9tIENvbW1vbk1hcmsgc3BlY1xuY29uc3QgX3B1bmN0dWF0aW9uID0gJ1xcXFxwe1B9JCs8PT5gXnx+JztcbmNvbnN0IHB1bmN0dWF0aW9uID0gZWRpdCgvXigoPyFbKl9dKVtcXHNwdW5jdHVhdGlvbl0pLywgJ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBfcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4vLyBzZXF1ZW5jZXMgZW0gc2hvdWxkIHNraXAgb3ZlciBbdGl0bGVdKGxpbmspLCBgY29kZWAsIDxodG1sPlxuY29uc3QgYmxvY2tTa2lwID0gL1xcW1teW1xcXV0qP1xcXVxcKFteXFwoXFwpXSo/XFwpfGBbXmBdKj9gfDxbXjw+XSo/Pi9nO1xuY29uc3QgZW1TdHJvbmdMRGVsaW0gPSBlZGl0KC9eKD86XFwqKyg/OigoPyFcXCopW3B1bmN0XSl8W15cXHMqXSkpfF5fKyg/OigoPyFfKVtwdW5jdF0pfChbXlxcc19dKSkvLCAndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IGVtU3Ryb25nUkRlbGltQXN0ID0gZWRpdCgnXlteXypdKj9fX1teXypdKj9cXFxcKlteXypdKj8oPz1fXyknIC8vIFNraXAgb3JwaGFuIGluc2lkZSBzdHJvbmdcbiAgICArICd8W14qXSsoPz1bXipdKScgLy8gQ29uc3VtZSB0byBkZWxpbVxuICAgICsgJ3woPyFcXFxcKilbcHVuY3RdKFxcXFwqKykoPz1bXFxcXHNdfCQpJyAvLyAoMSkgIyoqKiBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3xbXnB1bmN0XFxcXHNdKFxcXFwqKykoPyFcXFxcKikoPz1bcHVuY3RcXFxcc118JCknIC8vICgyKSBhKioqIywgYSoqKiBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3woPyFcXFxcKilbcHVuY3RcXFxcc10oXFxcXCorKSg/PVtecHVuY3RcXFxcc10pJyAvLyAoMykgIyoqKmEsICoqKmEgY2FuIG9ubHkgYmUgTGVmdCBEZWxpbWl0ZXJcbiAgICArICd8W1xcXFxzXShcXFxcKispKD8hXFxcXCopKD89W3B1bmN0XSknIC8vICg0KSAqKiojIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IVxcXFwqKVtwdW5jdF0oXFxcXCorKSg/IVxcXFwqKSg/PVtwdW5jdF0pJyAvLyAoNSkgIyoqKiMgY2FuIGJlIGVpdGhlciBMZWZ0IG9yIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3xbXnB1bmN0XFxcXHNdKFxcXFwqKykoPz1bXnB1bmN0XFxcXHNdKScsICdndScpIC8vICg2KSBhKioqYSBjYW4gYmUgZWl0aGVyIExlZnQgb3IgUmlnaHQgRGVsaW1pdGVyXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIF9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbi8vICg2KSBOb3QgYWxsb3dlZCBmb3IgX1xuY29uc3QgZW1TdHJvbmdSRGVsaW1VbmQgPSBlZGl0KCdeW15fKl0qP1xcXFwqXFxcXCpbXl8qXSo/X1teXypdKj8oPz1cXFxcKlxcXFwqKScgLy8gU2tpcCBvcnBoYW4gaW5zaWRlIHN0cm9uZ1xuICAgICsgJ3xbXl9dKyg/PVteX10pJyAvLyBDb25zdW1lIHRvIGRlbGltXG4gICAgKyAnfCg/IV8pW3B1bmN0XShfKykoPz1bXFxcXHNdfCQpJyAvLyAoMSkgI19fXyBjYW4gb25seSBiZSBhIFJpZ2h0IERlbGltaXRlclxuICAgICsgJ3xbXnB1bmN0XFxcXHNdKF8rKSg/IV8pKD89W3B1bmN0XFxcXHNdfCQpJyAvLyAoMikgYV9fXyMsIGFfX18gY2FuIG9ubHkgYmUgYSBSaWdodCBEZWxpbWl0ZXJcbiAgICArICd8KD8hXylbcHVuY3RcXFxcc10oXyspKD89W15wdW5jdFxcXFxzXSknIC8vICgzKSAjX19fYSwgX19fYSBjYW4gb25seSBiZSBMZWZ0IERlbGltaXRlclxuICAgICsgJ3xbXFxcXHNdKF8rKSg/IV8pKD89W3B1bmN0XSknIC8vICg0KSBfX18jIGNhbiBvbmx5IGJlIExlZnQgRGVsaW1pdGVyXG4gICAgKyAnfCg/IV8pW3B1bmN0XShfKykoPyFfKSg/PVtwdW5jdF0pJywgJ2d1JykgLy8gKDUpICNfX18jIGNhbiBiZSBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbWl0ZXJcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYW55UHVuY3R1YXRpb24gPSBlZGl0KC9cXFxcKFtwdW5jdF0pLywgJ2d1JylcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuY29uc3QgYXV0b2xpbmsgPSBlZGl0KC9ePChzY2hlbWU6W15cXHNcXHgwMC1cXHgxZjw+XSp8ZW1haWwpPi8pXG4gICAgLnJlcGxhY2UoJ3NjaGVtZScsIC9bYS16QS1aXVthLXpBLVowLTkrLi1dezEsMzF9LylcbiAgICAucmVwbGFjZSgnZW1haWwnLCAvW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXSsoQClbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKyg/IVstX10pLylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IF9pbmxpbmVDb21tZW50ID0gZWRpdChfY29tbWVudCkucmVwbGFjZSgnKD86LS0+fCQpJywgJy0tPicpLmdldFJlZ2V4KCk7XG5jb25zdCB0YWcgPSBlZGl0KCdeY29tbWVudCdcbiAgICArICd8XjwvW2EtekEtWl1bXFxcXHc6LV0qXFxcXHMqPicgLy8gc2VsZi1jbG9zaW5nIHRhZ1xuICAgICsgJ3xePFthLXpBLVpdW1xcXFx3LV0qKD86YXR0cmlidXRlKSo/XFxcXHMqLz8+JyAvLyBvcGVuIHRhZ1xuICAgICsgJ3xePFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz4nIC8vIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGUuZy4gPD9waHAgPz5cbiAgICArICd8XjwhW2EtekEtWl0rXFxcXHNbXFxcXHNcXFxcU10qPz4nIC8vIGRlY2xhcmF0aW9uLCBlLmcuIDwhRE9DVFlQRSBodG1sPlxuICAgICsgJ3xePCFcXFxcW0NEQVRBXFxcXFtbXFxcXHNcXFxcU10qP1xcXFxdXFxcXF0+JykgLy8gQ0RBVEEgc2VjdGlvblxuICAgIC5yZXBsYWNlKCdjb21tZW50JywgX2lubGluZUNvbW1lbnQpXG4gICAgLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IF9pbmxpbmVMYWJlbCA9IC8oPzpcXFsoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSpcXF18XFxcXC58YFteYF0qYHxbXlxcW1xcXVxcXFxgXSkqPy87XG5jb25zdCBsaW5rID0gZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKFxccyooaHJlZikoPzpcXHMrKHRpdGxlKSk/XFxzKlxcKS8pXG4gICAgLnJlcGxhY2UoJ2xhYmVsJywgX2lubGluZUxhYmVsKVxuICAgIC5yZXBsYWNlKCdocmVmJywgLzwoPzpcXFxcLnxbXlxcbjw+XFxcXF0pKz58W15cXHNcXHgwMC1cXHgxZl0qLylcbiAgICAucmVwbGFjZSgndGl0bGUnLCAvXCIoPzpcXFxcXCI/fFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwnP3xbXidcXFxcXSkqJ3xcXCgoPzpcXFxcXFwpP3xbXilcXFxcXSkqXFwpLylcbiAgICAuZ2V0UmVnZXgoKTtcbmNvbnN0IHJlZmxpbmsgPSBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxbKHJlZilcXF0vKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9pbmxpbmVMYWJlbClcbiAgICAucmVwbGFjZSgncmVmJywgX2Jsb2NrTGFiZWwpXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCBub2xpbmsgPSBlZGl0KC9eIT9cXFsocmVmKVxcXSg/OlxcW1xcXSk/LylcbiAgICAucmVwbGFjZSgncmVmJywgX2Jsb2NrTGFiZWwpXG4gICAgLmdldFJlZ2V4KCk7XG5jb25zdCByZWZsaW5rU2VhcmNoID0gZWRpdCgncmVmbGlua3xub2xpbmsoPyFcXFxcKCknLCAnZycpXG4gICAgLnJlcGxhY2UoJ3JlZmxpbmsnLCByZWZsaW5rKVxuICAgIC5yZXBsYWNlKCdub2xpbmsnLCBub2xpbmspXG4gICAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmVOb3JtYWwgPSB7XG4gICAgX2JhY2twZWRhbDogbm9vcFRlc3QsIC8vIG9ubHkgdXNlZCBmb3IgR0ZNIHVybFxuICAgIGFueVB1bmN0dWF0aW9uLFxuICAgIGF1dG9saW5rLFxuICAgIGJsb2NrU2tpcCxcbiAgICBicixcbiAgICBjb2RlOiBpbmxpbmVDb2RlLFxuICAgIGRlbDogbm9vcFRlc3QsXG4gICAgZW1TdHJvbmdMRGVsaW0sXG4gICAgZW1TdHJvbmdSRGVsaW1Bc3QsXG4gICAgZW1TdHJvbmdSRGVsaW1VbmQsXG4gICAgZXNjYXBlLFxuICAgIGxpbmssXG4gICAgbm9saW5rLFxuICAgIHB1bmN0dWF0aW9uLFxuICAgIHJlZmxpbmssXG4gICAgcmVmbGlua1NlYXJjaCxcbiAgICB0YWcsXG4gICAgdGV4dDogaW5saW5lVGV4dCxcbiAgICB1cmw6IG5vb3BUZXN0XG59O1xuLyoqXG4gKiBQZWRhbnRpYyBJbmxpbmUgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmVQZWRhbnRpYyA9IHtcbiAgICAuLi5pbmxpbmVOb3JtYWwsXG4gICAgbGluazogZWRpdCgvXiE/XFxbKGxhYmVsKVxcXVxcKCguKj8pXFwpLylcbiAgICAgICAgLnJlcGxhY2UoJ2xhYmVsJywgX2lubGluZUxhYmVsKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICByZWZsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8pXG4gICAgICAgIC5yZXBsYWNlKCdsYWJlbCcsIF9pbmxpbmVMYWJlbClcbiAgICAgICAgLmdldFJlZ2V4KClcbn07XG4vKipcbiAqIEdGTSBJbmxpbmUgR3JhbW1hclxuICovXG5jb25zdCBpbmxpbmVHZm0gPSB7XG4gICAgLi4uaW5saW5lTm9ybWFsLFxuICAgIGVzY2FwZTogZWRpdChlc2NhcGUpLnJlcGxhY2UoJ10pJywgJ358XSknKS5nZXRSZWdleCgpLFxuICAgIHVybDogZWRpdCgvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sICdpJylcbiAgICAgICAgLnJlcGxhY2UoJ2VtYWlsJywgL1tBLVphLXowLTkuXystXSsoQClbYS16QS1aMC05LV9dKyg/OlxcLlthLXpBLVowLTktX10qW2EtekEtWjAtOV0pKyg/IVstX10pLylcbiAgICAgICAgLmdldFJlZ2V4KCksXG4gICAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl8nXCJ+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl8nXCJ+KV0rKD8hJCkpKy8sXG4gICAgZGVsOiAvXih+fj8pKD89W15cXHN+XSkoW1xcc1xcU10qP1teXFxzfl0pXFwxKD89W15+XXwkKS8sXG4gICAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS9cbn07XG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cbmNvbnN0IGlubGluZUJyZWFrcyA9IHtcbiAgICAuLi5pbmxpbmVHZm0sXG4gICAgYnI6IGVkaXQoYnIpLnJlcGxhY2UoJ3syLH0nLCAnKicpLmdldFJlZ2V4KCksXG4gICAgdGV4dDogZWRpdChpbmxpbmVHZm0udGV4dClcbiAgICAgICAgLnJlcGxhY2UoJ1xcXFxiXycsICdcXFxcYl98IHsyLH1cXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKC9cXHsyLFxcfS9nLCAnKicpXG4gICAgICAgIC5nZXRSZWdleCgpXG59O1xuLyoqXG4gKiBleHBvcnRzXG4gKi9cbmNvbnN0IGJsb2NrID0ge1xuICAgIG5vcm1hbDogYmxvY2tOb3JtYWwsXG4gICAgZ2ZtOiBibG9ja0dmbSxcbiAgICBwZWRhbnRpYzogYmxvY2tQZWRhbnRpY1xufTtcbmNvbnN0IGlubGluZSA9IHtcbiAgICBub3JtYWw6IGlubGluZU5vcm1hbCxcbiAgICBnZm06IGlubGluZUdmbSxcbiAgICBicmVha3M6IGlubGluZUJyZWFrcyxcbiAgICBwZWRhbnRpYzogaW5saW5lUGVkYW50aWNcbn07XG5cbi8qKlxuICogQmxvY2sgTGV4ZXJcbiAqL1xuY2xhc3MgX0xleGVyIHtcbiAgICB0b2tlbnM7XG4gICAgb3B0aW9ucztcbiAgICBzdGF0ZTtcbiAgICB0b2tlbml6ZXI7XG4gICAgaW5saW5lUXVldWU7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAvLyBUb2tlbkxpc3QgY2Fubm90IGJlIGNyZWF0ZWQgaW4gb25lIGdvXG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zLmxpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgICAgIHRoaXMub3B0aW9ucy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyIHx8IG5ldyBfVG9rZW5pemVyKCk7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplcjtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy50b2tlbml6ZXIubGV4ZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLmlubGluZVF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbkxpbms6IGZhbHNlLFxuICAgICAgICAgICAgaW5SYXdCbG9jazogZmFsc2UsXG4gICAgICAgICAgICB0b3A6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVsZXMgPSB7XG4gICAgICAgICAgICBibG9jazogYmxvY2subm9ybWFsLFxuICAgICAgICAgICAgaW5saW5lOiBpbmxpbmUubm9ybWFsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2sucGVkYW50aWM7XG4gICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUucGVkYW50aWM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5nZm07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5icmVha3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuZ2ZtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5pemVyLnJ1bGVzID0gcnVsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9zZSBSdWxlc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcnVsZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgIGlubGluZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBsZXgoc3JjLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxleGVyID0gbmV3IF9MZXhlcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgbGV4SW5saW5lKHNyYywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBfTGV4ZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBsZXhlci5pbmxpbmVUb2tlbnMoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcHJvY2Vzc2luZ1xuICAgICAqL1xuICAgIGxleChzcmMpIHtcbiAgICAgICAgc3JjID0gc3JjXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJyk7XG4gICAgICAgIHRoaXMuYmxvY2tUb2tlbnMoc3JjLCB0aGlzLnRva2Vucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuaW5saW5lUXVldWVbaV07XG4gICAgICAgICAgICB0aGlzLmlubGluZVRva2VucyhuZXh0LnNyYywgbmV4dC50b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICAgIH1cbiAgICBibG9ja1Rva2VucyhzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9cXHQvZywgJyAgICAnKS5yZXBsYWNlKC9eICskL2dtLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXiggKikoXFx0KykvZ20sIChfLCBsZWFkaW5nLCB0YWJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlYWRpbmcgKyAnICAgICcucmVwZWF0KHRhYnMubGVuZ3RoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgbGV0IGxhc3RUb2tlbjtcbiAgICAgICAgbGV0IGN1dFNyYztcbiAgICAgICAgbGV0IGxhc3RQYXJhZ3JhcGhDbGlwcGVkO1xuICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5ibG9ja1xuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrLnNvbWUoKGV4dFRva2VuaXplcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gPSBleHRUb2tlbml6ZXIuY2FsbCh7IGxleGVyOiB0aGlzIH0sIHNyYywgdG9rZW5zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbmV3bGluZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3BhY2Uoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnJhdy5sZW5ndGggPT09IDEgJiYgdG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBhIHNpbmdsZSBcXG4gYXMgYSBzcGFjZXIsIGl0J3MgdGVybWluYXRpbmcgdGhlIGxhc3QgbGluZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gbW92ZSBpdCB0aGVyZSBzbyB0aGF0IHdlIGRvbid0IGdldCB1bm5lY2Vzc2FyeSBwYXJhZ3JhcGggdGFnc1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnJhdyArPSAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb2RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2RlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgLy8gQW4gaW5kZW50ZWQgY29kZSBibG9jayBjYW5ub3QgaW50ZXJydXB0IGEgcGFyYWdyYXBoLlxuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmZW5jZXNcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmZlbmNlcyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoZWFkaW5nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5oZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhyXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ocihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBibG9ja3F1b3RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ibG9ja3F1b3RlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxpc3RcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpc3Qoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaHRtbFxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaHRtbChzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWZcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmRlZihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgKGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJyB8fCBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy50b2tlbnMubGlua3NbdG9rZW4udGFnXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogdG9rZW4uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b2tlbi50aXRsZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRhYmxlIChnZm0pXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWJsZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaGVhZGluZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGhlYWRpbmcoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdG9wLWxldmVsIHBhcmFncmFwaFxuICAgICAgICAgICAgLy8gcHJldmVudCBwYXJhZ3JhcGggY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICAgICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0QmxvY2suZm9yRWFjaCgoZ2V0U3RhcnRJbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wU3RhcnQgPSBnZXRTdGFydEluZGV4LmNhbGwoeyBsZXhlcjogdGhpcyB9LCB0ZW1wU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wU3RhcnQgPT09ICdudW1iZXInICYmIHRlbXBTdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gTWF0aC5taW4oc3RhcnRJbmRleCwgdGVtcFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEluZGV4IDwgSW5maW5pdHkgJiYgc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dFNyYyA9IHNyYy5zdWJzdHJpbmcoMCwgc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5wYXJhZ3JhcGgoY3V0U3JjKSkpIHtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFyYWdyYXBoQ2xpcHBlZCAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RQYXJhZ3JhcGhDbGlwcGVkID0gKGN1dFNyYy5sZW5ndGggIT09IHNyYy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50ZXh0KHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnRvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIGlubGluZShzcmMsIHRva2VucyA9IFtdKSB7XG4gICAgICAgIHRoaXMuaW5saW5lUXVldWUucHVzaCh7IHNyYywgdG9rZW5zIH0pO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgaW5saW5lVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICAgICAgbGV0IHRva2VuLCBsYXN0VG9rZW4sIGN1dFNyYztcbiAgICAgICAgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcbiAgICAgICAgbGV0IG1hc2tlZFNyYyA9IHNyYztcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBsZXQga2VlcFByZXZDaGFyLCBwcmV2Q2hhcjtcbiAgICAgICAgLy8gTWFzayBvdXQgcmVmbGlua3NcbiAgICAgICAgaWYgKHRoaXMudG9rZW5zLmxpbmtzKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IE9iamVjdC5rZXlzKHRoaXMudG9rZW5zLmxpbmtzKTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlua3MuaW5jbHVkZXMobWF0Y2hbMF0uc2xpY2UobWF0Y2hbMF0ubGFzdEluZGV4T2YoJ1snKSArIDEsIC0xKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyAnYScucmVwZWF0KG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmxhc3RJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFzayBvdXQgb3RoZXIgYmxvY2tzXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmJsb2NrU2tpcC5sYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hc2sgb3V0IGVzY2FwZWQgY2hhcmFjdGVyc1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICcrKycgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLmFueVB1bmN0dWF0aW9uLmxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHNyYykge1xuICAgICAgICAgICAgaWYgKCFrZWVwUHJldkNoYXIpIHtcbiAgICAgICAgICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2VlcFByZXZDaGFyID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBleHRlbnNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmVcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5pbmxpbmUuc29tZSgoZXh0VG9rZW5pemVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2NhcGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVzY2FwZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0YWdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhZyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9IHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGlua1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGluayhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZWZsaW5rLCBub2xpbmtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnJlZmxpbmsoc3JjLCB0aGlzLnRva2Vucy5saW5rcykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbSAmIHN0cm9uZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZW1TdHJvbmcoc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29kZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuY29kZXNwYW4oc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYnJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJyKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlbCAoZ2ZtKVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVsKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGF1dG9saW5rXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5hdXRvbGluayhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1cmwgKGdmbSlcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5pbkxpbmsgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudXJsKHNyYykpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXh0XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGlubGluZVRleHQgY29uc3VtaW5nIGV4dGVuc2lvbnMgYnkgY2xpcHBpbmcgJ3NyYycgdG8gZXh0ZW5zaW9uIHN0YXJ0XG4gICAgICAgICAgICBjdXRTcmMgPSBzcmM7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBTcmMgPSBzcmMuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXBTdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZS5mb3JFYWNoKChnZXRTdGFydEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdGFydCA9IGdldFN0YXJ0SW5kZXguY2FsbCh7IGxleGVyOiB0aGlzIH0sIHRlbXBTcmMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydEluZGV4LCB0ZW1wU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuaW5saW5lVGV4dChjdXRTcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ucmF3LnNsaWNlKC0xKSAhPT0gJ18nKSB7IC8vIFRyYWNrIHByZXZDaGFyIGJlZm9yZSBzdHJpbmcgb2YgX19fXyBzdGFydGVkXG4gICAgICAgICAgICAgICAgICAgIHByZXZDaGFyID0gdG9rZW4ucmF3LnNsaWNlKC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2VlcFByZXZDaGFyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0VG9rZW4gJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5cbi8qKlxuICogUmVuZGVyZXJcbiAqL1xuY2xhc3MgX1JlbmRlcmVyIHtcbiAgICBvcHRpb25zO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgfVxuICAgIGNvZGUoY29kZSwgaW5mb3N0cmluZywgZXNjYXBlZCkge1xuICAgICAgICBjb25zdCBsYW5nID0gKGluZm9zdHJpbmcgfHwgJycpLm1hdGNoKC9eXFxTKi8pPy5bMF07XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcbiQvLCAnJykgKyAnXFxuJztcbiAgICAgICAgaWYgKCFsYW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgICAgICAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlJDEoY29kZSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwibGFuZ3VhZ2UtJ1xuICAgICAgICAgICAgKyBlc2NhcGUkMShsYW5nKVxuICAgICAgICAgICAgKyAnXCI+J1xuICAgICAgICAgICAgKyAoZXNjYXBlZCA/IGNvZGUgOiBlc2NhcGUkMShjb2RlLCB0cnVlKSlcbiAgICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH1cbiAgICBibG9ja3F1b3RlKHF1b3RlKSB7XG4gICAgICAgIHJldHVybiBgPGJsb2NrcXVvdGU+XFxuJHtxdW90ZX08L2Jsb2NrcXVvdGU+XFxuYDtcbiAgICB9XG4gICAgaHRtbChodG1sLCBibG9jaykge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgaGVhZGluZyh0ZXh0LCBsZXZlbCwgcmF3KSB7XG4gICAgICAgIC8vIGlnbm9yZSBJRHNcbiAgICAgICAgcmV0dXJuIGA8aCR7bGV2ZWx9PiR7dGV4dH08L2gke2xldmVsfT5cXG5gO1xuICAgIH1cbiAgICBocigpIHtcbiAgICAgICAgcmV0dXJuICc8aHI+XFxuJztcbiAgICB9XG4gICAgbGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCkge1xuICAgICAgICBjb25zdCB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnO1xuICAgICAgICBjb25zdCBzdGFydGF0dCA9IChvcmRlcmVkICYmIHN0YXJ0ICE9PSAxKSA/ICgnIHN0YXJ0PVwiJyArIHN0YXJ0ICsgJ1wiJykgOiAnJztcbiAgICAgICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydGF0dCArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgICB9XG4gICAgbGlzdGl0ZW0odGV4dCwgdGFzaywgY2hlY2tlZCkge1xuICAgICAgICByZXR1cm4gYDxsaT4ke3RleHR9PC9saT5cXG5gO1xuICAgIH1cbiAgICBjaGVja2JveChjaGVja2VkKSB7XG4gICAgICAgIHJldHVybiAnPGlucHV0ICdcbiAgICAgICAgICAgICsgKGNoZWNrZWQgPyAnY2hlY2tlZD1cIlwiICcgOiAnJylcbiAgICAgICAgICAgICsgJ2Rpc2FibGVkPVwiXCIgdHlwZT1cImNoZWNrYm94XCI+JztcbiAgICB9XG4gICAgcGFyYWdyYXBoKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8cD4ke3RleHR9PC9wPlxcbmA7XG4gICAgfVxuICAgIHRhYmxlKGhlYWRlciwgYm9keSkge1xuICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgIGJvZHkgPSBgPHRib2R5PiR7Ym9keX08L3Rib2R5PmA7XG4gICAgICAgIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICAgICAgICAgICsgJzx0aGVhZD5cXG4nXG4gICAgICAgICAgICArIGhlYWRlclxuICAgICAgICAgICAgKyAnPC90aGVhZD5cXG4nXG4gICAgICAgICAgICArIGJvZHlcbiAgICAgICAgICAgICsgJzwvdGFibGU+XFxuJztcbiAgICB9XG4gICAgdGFibGVyb3coY29udGVudCkge1xuICAgICAgICByZXR1cm4gYDx0cj5cXG4ke2NvbnRlbnR9PC90cj5cXG5gO1xuICAgIH1cbiAgICB0YWJsZWNlbGwoY29udGVudCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgICAgICBjb25zdCB0YWcgPSBmbGFncy5hbGlnblxuICAgICAgICAgICAgPyBgPCR7dHlwZX0gYWxpZ249XCIke2ZsYWdzLmFsaWdufVwiPmBcbiAgICAgICAgICAgIDogYDwke3R5cGV9PmA7XG4gICAgICAgIHJldHVybiB0YWcgKyBjb250ZW50ICsgYDwvJHt0eXBlfT5cXG5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzcGFuIGxldmVsIHJlbmRlcmVyXG4gICAgICovXG4gICAgc3Ryb25nKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8c3Ryb25nPiR7dGV4dH08L3N0cm9uZz5gO1xuICAgIH1cbiAgICBlbSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBgPGVtPiR7dGV4dH08L2VtPmA7XG4gICAgfVxuICAgIGNvZGVzcGFuKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8Y29kZT4ke3RleHR9PC9jb2RlPmA7XG4gICAgfVxuICAgIGJyKCkge1xuICAgICAgICByZXR1cm4gJzxicj4nO1xuICAgIH1cbiAgICBkZWwodGV4dCkge1xuICAgICAgICByZXR1cm4gYDxkZWw+JHt0ZXh0fTwvZGVsPmA7XG4gICAgfVxuICAgIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgY29uc3QgY2xlYW5IcmVmID0gY2xlYW5VcmwoaHJlZik7XG4gICAgICAgIGlmIChjbGVhbkhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSBjbGVhbkhyZWY7XG4gICAgICAgIGxldCBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNsZWFuSHJlZiA9IGNsZWFuVXJsKGhyZWYpO1xuICAgICAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBocmVmID0gY2xlYW5IcmVmO1xuICAgICAgICBsZXQgb3V0ID0gYDxpbWcgc3JjPVwiJHtocmVmfVwiIGFsdD1cIiR7dGV4dH1cImA7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgb3V0ICs9IGAgdGl0bGU9XCIke3RpdGxlfVwiYDtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJz4nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB0ZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIFRleHRSZW5kZXJlclxuICogcmV0dXJucyBvbmx5IHRoZSB0ZXh0dWFsIHBhcnQgb2YgdGhlIHRva2VuXG4gKi9cbmNsYXNzIF9UZXh0UmVuZGVyZXIge1xuICAgIC8vIG5vIG5lZWQgZm9yIGJsb2NrIGxldmVsIHJlbmRlcmVyc1xuICAgIHN0cm9uZyh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBlbSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb2Rlc3Bhbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBkZWwodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgaHRtbCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB0ZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgYnIoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cbi8qKlxuICogUGFyc2luZyAmIENvbXBpbGluZ1xuICovXG5jbGFzcyBfUGFyc2VyIHtcbiAgICBvcHRpb25zO1xuICAgIHJlbmRlcmVyO1xuICAgIHRleHRSZW5kZXJlcjtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IF9SZW5kZXJlcigpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMudGV4dFJlbmRlcmVyID0gbmV3IF9UZXh0UmVuZGVyZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9QYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2UodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VJbmxpbmUodG9rZW5zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBfUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIExvb3BcbiAgICAgKi9cbiAgICBwYXJzZSh0b2tlbnMsIHRvcCA9IHRydWUpIHtcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW2dlbmVyaWNUb2tlbi50eXBlXS5jYWxsKHsgcGFyc2VyOiB0aGlzIH0sIGdlbmVyaWNUb2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHJldCAhPT0gZmFsc2UgfHwgIVsnc3BhY2UnLCAnaHInLCAnaGVhZGluZycsICdjb2RlJywgJ3RhYmxlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcsICdodG1sJywgJ3BhcmFncmFwaCcsICd0ZXh0J10uaW5jbHVkZXMoZ2VuZXJpY1Rva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnaHInOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmhyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaGVhZGluZyh0aGlzLnBhcnNlSW5saW5lKGhlYWRpbmdUb2tlbi50b2tlbnMpLCBoZWFkaW5nVG9rZW4uZGVwdGgsIHVuZXNjYXBlKHRoaXMucGFyc2VJbmxpbmUoaGVhZGluZ1Rva2VuLnRva2VucywgdGhpcy50ZXh0UmVuZGVyZXIpKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjb2RlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuY29kZShjb2RlVG9rZW4udGV4dCwgY29kZVRva2VuLmxhbmcsICEhY29kZVRva2VuLmVzY2FwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndGFibGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhlYWRlciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAvLyBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWJsZVRva2VuLmhlYWRlci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHRhYmxlVG9rZW4uaGVhZGVyW2pdLnRva2VucyksIHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGFibGVUb2tlbi5hbGlnbltqXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgKz0gdGhpcy5yZW5kZXJlci50YWJsZXJvdyhjZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWJsZVRva2VuLnJvd3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRhYmxlVG9rZW4ucm93c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcm93Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHJvd1trXS50b2tlbnMpLCB7IGhlYWRlcjogZmFsc2UsIGFsaWduOiB0YWJsZVRva2VuLmFsaWduW2tdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlKGhlYWRlciwgYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdibG9ja3F1b3RlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja3F1b3RlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMucGFyc2UoYmxvY2txdW90ZVRva2VuLnRva2Vucyk7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmJsb2NrcXVvdGUoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJlZCA9IGxpc3RUb2tlbi5vcmRlcmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGxpc3RUb2tlbi5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9vc2UgPSBsaXN0VG9rZW4ubG9vc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBib2R5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGlzdFRva2VuLml0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbGlzdFRva2VuLml0ZW1zW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGl0ZW0uY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBpdGVtLnRhc2s7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbUJvZHkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IHRoaXMucmVuZGVyZXIuY2hlY2tib3goISFjaGVja2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0udG9rZW5zICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnRva2Vucy51bnNoaWZ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY2hlY2tib3ggKyAnICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQm9keSArPSBjaGVja2JveCArICcgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtQm9keSArPSB0aGlzLnBhcnNlKGl0ZW0udG9rZW5zLCBsb29zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIubGlzdGl0ZW0oaXRlbUJvZHksIHRhc2ssICEhY2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdodG1sJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBodG1sVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHRtbChodG1sVG9rZW4udGV4dCwgaHRtbFRva2VuLmJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3BhcmFncmFwaCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VJbmxpbmUocGFyYWdyYXBoVG9rZW4udG9rZW5zKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0Jzoge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGxldCBib2R5ID0gdGV4dFRva2VuLnRva2VucyA/IHRoaXMucGFyc2VJbmxpbmUodGV4dFRva2VuLnRva2VucykgOiB0ZXh0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgKyAxIDwgdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbaSArIDFdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFRva2VuID0gdG9rZW5zWysraV07XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ICs9ICdcXG4nICsgKHRleHRUb2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRleHRUb2tlbi50b2tlbnMpIDogdGV4dFRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSB0b3AgPyB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaChib2R5KSA6IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBJbmxpbmUgVG9rZW5zXG4gICAgICovXG4gICAgcGFyc2VJbmxpbmUodG9rZW5zLCByZW5kZXJlcikge1xuICAgICAgICByZW5kZXJlciA9IHJlbmRlcmVyIHx8IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgLy8gUnVuIGFueSByZW5kZXJlciBleHRlbnNpb25zXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVyc1t0b2tlbi50eXBlXS5jYWxsKHsgcGFyc2VyOiB0aGlzIH0sIHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydlc2NhcGUnLCAnaHRtbCcsICdsaW5rJywgJ2ltYWdlJywgJ3N0cm9uZycsICdlbScsICdjb2Rlc3BhbicsICdicicsICdkZWwnLCAndGV4dCddLmluY2x1ZGVzKHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZXQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VzY2FwZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnRleHQoZXNjYXBlVG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdodG1sJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaHRtbCh0YWdUb2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2xpbmsnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmtUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIubGluayhsaW5rVG9rZW4uaHJlZiwgbGlua1Rva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKGxpbmtUb2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdpbWFnZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuaW1hZ2UoaW1hZ2VUb2tlbi5ocmVmLCBpbWFnZVRva2VuLnRpdGxlLCBpbWFnZVRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnc3Ryb25nJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJvbmdUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuc3Ryb25nKHRoaXMucGFyc2VJbmxpbmUoc3Ryb25nVG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZW0nOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmVtKHRoaXMucGFyc2VJbmxpbmUoZW1Ub2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdjb2Rlc3Bhbic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZXNwYW5Ub2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuY29kZXNwYW4oY29kZXNwYW5Ub2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2JyJzoge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuYnIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2RlbCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmRlbCh0aGlzLnBhcnNlSW5saW5lKGRlbFRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0ZXh0VG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdUb2tlbiB3aXRoIFwiJyArIHRva2VuLnR5cGUgKyAnXCIgdHlwZSB3YXMgbm90IGZvdW5kLic7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn1cblxuY2xhc3MgX0hvb2tzIHtcbiAgICBvcHRpb25zO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgfVxuICAgIHN0YXRpYyBwYXNzVGhyb3VnaEhvb2tzID0gbmV3IFNldChbXG4gICAgICAgICdwcmVwcm9jZXNzJyxcbiAgICAgICAgJ3Bvc3Rwcm9jZXNzJyxcbiAgICAgICAgJ3Byb2Nlc3NBbGxUb2tlbnMnXG4gICAgXSk7XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBtYXJrZG93biBiZWZvcmUgbWFya2VkXG4gICAgICovXG4gICAgcHJlcHJvY2VzcyhtYXJrZG93bikge1xuICAgICAgICByZXR1cm4gbWFya2Rvd247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgSFRNTCBhZnRlciBtYXJrZWQgaXMgZmluaXNoZWRcbiAgICAgKi9cbiAgICBwb3N0cHJvY2VzcyhodG1sKSB7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGFsbCB0b2tlbnMgYmVmb3JlIHdhbGsgdG9rZW5zXG4gICAgICovXG4gICAgcHJvY2Vzc0FsbFRva2Vucyh0b2tlbnMpIHtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5cbmNsYXNzIE1hcmtlZCB7XG4gICAgZGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHMoKTtcbiAgICBvcHRpb25zID0gdGhpcy5zZXRPcHRpb25zO1xuICAgIHBhcnNlID0gdGhpcy4jcGFyc2VNYXJrZG93bihfTGV4ZXIubGV4LCBfUGFyc2VyLnBhcnNlKTtcbiAgICBwYXJzZUlubGluZSA9IHRoaXMuI3BhcnNlTWFya2Rvd24oX0xleGVyLmxleElubGluZSwgX1BhcnNlci5wYXJzZUlubGluZSk7XG4gICAgUGFyc2VyID0gX1BhcnNlcjtcbiAgICBSZW5kZXJlciA9IF9SZW5kZXJlcjtcbiAgICBUZXh0UmVuZGVyZXIgPSBfVGV4dFJlbmRlcmVyO1xuICAgIExleGVyID0gX0xleGVyO1xuICAgIFRva2VuaXplciA9IF9Ub2tlbml6ZXI7XG4gICAgSG9va3MgPSBfSG9va3M7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICB0aGlzLnVzZSguLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIGNhbGxiYWNrIGZvciBldmVyeSB0b2tlblxuICAgICAqL1xuICAgIHdhbGtUb2tlbnModG9rZW5zLCBjYWxsYmFjaykge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KGNhbGxiYWNrLmNhbGwodGhpcywgdG9rZW4pKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RhYmxlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZVRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiB0YWJsZVRva2VuLmhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMoY2VsbC50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGVUb2tlbi5yb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMoY2VsbC50b2tlbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2xpc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhsaXN0VG9rZW4uaXRlbXMsIGNhbGxiYWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdlbmVyaWNUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5leHRlbnNpb25zPy5jaGlsZFRva2Vucz8uW2dlbmVyaWNUb2tlbi50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0cy5leHRlbnNpb25zLmNoaWxkVG9rZW5zW2dlbmVyaWNUb2tlbi50eXBlXS5mb3JFYWNoKChjaGlsZFRva2VucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IGdlbmVyaWNUb2tlbltjaGlsZFRva2Vuc10uZmxhdChJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnModG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZ2VuZXJpY1Rva2VuLnRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMoZ2VuZXJpY1Rva2VuLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICB1c2UoLi4uYXJncykge1xuICAgICAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5kZWZhdWx0cy5leHRlbnNpb25zIHx8IHsgcmVuZGVyZXJzOiB7fSwgY2hpbGRUb2tlbnM6IHt9IH07XG4gICAgICAgIGFyZ3MuZm9yRWFjaCgocGFjaykgPT4ge1xuICAgICAgICAgICAgLy8gY29weSBvcHRpb25zIHRvIG5ldyBvYmplY3RcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSB7IC4uLnBhY2sgfTtcbiAgICAgICAgICAgIC8vIHNldCBhc3luYyB0byB0cnVlIGlmIGl0IHdhcyBzZXQgdG8gdHJ1ZSBiZWZvcmVcbiAgICAgICAgICAgIG9wdHMuYXN5bmMgPSB0aGlzLmRlZmF1bHRzLmFzeW5jIHx8IG9wdHMuYXN5bmMgfHwgZmFsc2U7XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFwiYWRkb25cIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBwYWNrLmV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXh0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0ZW5zaW9uIG5hbWUgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3JlbmRlcmVyJyBpbiBleHQpIHsgLy8gUmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlJlbmRlcmVyID0gZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgZXh0ZW5zaW9uIHdpdGggZnVuYyB0byBydW4gbmV3IGV4dGVuc2lvbiBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IGV4dC5yZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBleHQucmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0b2tlbml6ZXInIGluIGV4dCkgeyAvLyBUb2tlbml6ZXIgRXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleHQubGV2ZWwgfHwgKGV4dC5sZXZlbCAhPT0gJ2Jsb2NrJyAmJiBleHQubGV2ZWwgIT09ICdpbmxpbmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4dGVuc2lvbiBsZXZlbCBtdXN0IGJlICdibG9jaycgb3IgJ2lubGluZSdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRMZXZlbCA9IGV4dGVuc2lvbnNbZXh0LmxldmVsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dExldmVsLnVuc2hpZnQoZXh0LnRva2VuaXplcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zW2V4dC5sZXZlbF0gPSBbZXh0LnRva2VuaXplcl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0LnN0YXJ0KSB7IC8vIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciBzdGFydCBvZiB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHQubGV2ZWwgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnMuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydEJsb2NrLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRCbG9jayA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4dC5sZXZlbCA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZSA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgnY2hpbGRUb2tlbnMnIGluIGV4dCAmJiBleHQuY2hpbGRUb2tlbnMpIHsgLy8gQ2hpbGQgdG9rZW5zIHRvIGJlIHZpc2l0ZWQgYnkgd2Fsa1Rva2Vuc1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1tleHQubmFtZV0gPSBleHQuY2hpbGRUb2tlbnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcHRzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBcIm92ZXJ3cml0ZVwiIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2sucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZGVmYXVsdHMucmVuZGVyZXIgfHwgbmV3IF9SZW5kZXJlcih0aGlzLmRlZmF1bHRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay5yZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShwcm9wIGluIHJlbmRlcmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZW5kZXJlciAnJHtwcm9wfScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgb3B0aW9ucyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJQcm9wID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVuZGVyZXJGdW5jID0gcGFjay5yZW5kZXJlcltyZW5kZXJlclByb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2UmVuZGVyZXIgPSByZW5kZXJlcltyZW5kZXJlclByb3BdO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHJlbmRlcmVyIHdpdGggZnVuYyB0byBydW4gZXh0ZW5zaW9uLCBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyW3JlbmRlcmVyUHJvcF0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IHJlbmRlcmVyRnVuYy5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbml6ZXIgPSB0aGlzLmRlZmF1bHRzLnRva2VuaXplciB8fCBuZXcgX1Rva2VuaXplcih0aGlzLmRlZmF1bHRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocHJvcCBpbiB0b2tlbml6ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRva2VuaXplciAnJHtwcm9wfScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoWydvcHRpb25zJywgJ3J1bGVzJywgJ2xleGVyJ10uaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBvcHRpb25zLCBydWxlcywgYW5kIGxleGVyIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuaXplclByb3AgPSBwcm9wO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbml6ZXJGdW5jID0gcGFjay50b2tlbml6ZXJbdG9rZW5pemVyUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZUb2tlbml6ZXIgPSB0b2tlbml6ZXJbdG9rZW5pemVyUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdG9rZW5pemVyIHdpdGggZnVuYyB0byBydW4gZXh0ZW5zaW9uLCBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IHR5cGUgdG9rZW5pemVyIGZ1bmN0aW9uIGR5bmFtaWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIHRva2VuaXplclt0b2tlbml6ZXJQcm9wXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gdG9rZW5pemVyRnVuYy5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBwcmV2VG9rZW5pemVyLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vID09LS0gUGFyc2UgSG9va3MgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay5ob29rcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvb2tzID0gdGhpcy5kZWZhdWx0cy5ob29rcyB8fCBuZXcgX0hvb2tzKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHBhY2suaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocHJvcCBpbiBob29rcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaG9vayAnJHtwcm9wfScgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgb3B0aW9ucyBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3NQcm9wID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9va3NGdW5jID0gcGFjay5ob29rc1tob29rc1Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2SG9vayA9IGhvb2tzW2hvb2tzUHJvcF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChfSG9va3MucGFzc1Rocm91Z2hIb29rcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IHR5cGUgaG9vayBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3NbaG9va3NQcm9wXSA9IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpKS50aGVuKHJldCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IGhvb2tzRnVuYy5jYWxsKGhvb2tzLCBhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SG9vay5jYWxsKGhvb2tzLCByZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2Fubm90IHR5cGUgaG9vayBmdW5jdGlvbiBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9va3NbaG9va3NQcm9wXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IGhvb2tzRnVuYy5hcHBseShob29rcywgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcHJldkhvb2suYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLmhvb2tzID0gaG9va3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFdhbGtUb2tlbnMgZXh0ZW5zaW9ucyAtLT09IC8vXG4gICAgICAgICAgICBpZiAocGFjay53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2Fsa1Rva2VucyA9IHRoaXMuZGVmYXVsdHMud2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICBjb25zdCBwYWNrV2Fsa3Rva2VucyA9IHBhY2sud2Fsa1Rva2VucztcbiAgICAgICAgICAgICAgICBvcHRzLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChwYWNrV2Fsa3Rva2Vucy5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHdhbGtUb2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9wdHMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRzID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcHQgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxleGVyKHNyYywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX0xleGVyLmxleChzcmMsIG9wdGlvbnMgPz8gdGhpcy5kZWZhdWx0cyk7XG4gICAgfVxuICAgIHBhcnNlcih0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9QYXJzZXIucGFyc2UodG9rZW5zLCBvcHRpb25zID8/IHRoaXMuZGVmYXVsdHMpO1xuICAgIH1cbiAgICAjcGFyc2VNYXJrZG93bihsZXhlciwgcGFyc2VyKSB7XG4gICAgICAgIHJldHVybiAoc3JjLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcmlnT3B0ID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBvcHQgPSB7IC4uLnRoaXMuZGVmYXVsdHMsIC4uLm9yaWdPcHQgfTtcbiAgICAgICAgICAgIC8vIFNob3cgd2FybmluZyBpZiBhbiBleHRlbnNpb24gc2V0IGFzeW5jIHRvIHRydWUgYnV0IHRoZSBwYXJzZSB3YXMgY2FsbGVkIHdpdGggYXN5bmM6IGZhbHNlXG4gICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0cy5hc3luYyA9PT0gdHJ1ZSAmJiBvcmlnT3B0LmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICghb3B0LnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ21hcmtlZCgpOiBUaGUgYXN5bmMgb3B0aW9uIHdhcyBzZXQgdG8gdHJ1ZSBieSBhbiBleHRlbnNpb24uIFRoZSBhc3luYzogZmFsc2Ugb3B0aW9uIHNlbnQgdG8gcGFyc2Ugd2lsbCBiZSBpZ25vcmVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGhyb3dFcnJvciA9IHRoaXMuI29uRXJyb3IoISFvcHQuc2lsZW50LCAhIW9wdC5hc3luYyk7XG4gICAgICAgICAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAndW5kZWZpbmVkJyB8fCBzcmMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgb2YgdHlwZSAnXG4gICAgICAgICAgICAgICAgICAgICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNyYykgKyAnLCBzdHJpbmcgZXhwZWN0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0Lmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgb3B0Lmhvb2tzLm9wdGlvbnMgPSBvcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0LmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShvcHQuaG9va3MgPyBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpIDogc3JjKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihzcmMgPT4gbGV4ZXIoc3JjLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbih0b2tlbnMgPT4gb3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByb2Nlc3NBbGxUb2tlbnModG9rZW5zKSA6IHRva2VucylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW5zID0+IG9wdC53YWxrVG9rZW5zID8gUHJvbWlzZS5hbGwodGhpcy53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpKS50aGVuKCgpID0+IHRva2VucykgOiB0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRva2VucyA9PiBwYXJzZXIodG9rZW5zLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihodG1sID0+IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKSA6IGh0bWwpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aHJvd0Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5zID0gbGV4ZXIoc3JjLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gb3B0Lmhvb2tzLnByb2Nlc3NBbGxUb2tlbnModG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGh0bWwgPSBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA9IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAjb25FcnJvcihzaWxlbnQsIGFzeW5jKSB7XG4gICAgICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgICAgICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuICAgICAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICc8cD5BbiBlcnJvciBvY2N1cnJlZDo8L3A+PHByZT4nXG4gICAgICAgICAgICAgICAgICAgICsgZXNjYXBlJDEoZS5tZXNzYWdlICsgJycsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICsgJzwvcHJlPic7XG4gICAgICAgICAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5jb25zdCBtYXJrZWRJbnN0YW5jZSA9IG5ldyBNYXJrZWQoKTtcbmZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCkge1xuICAgIHJldHVybiBtYXJrZWRJbnN0YW5jZS5wYXJzZShzcmMsIG9wdCk7XG59XG4vKipcbiAqIFNldHMgdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyBIYXNoIG9mIG9wdGlvbnNcbiAqL1xubWFya2VkLm9wdGlvbnMgPVxuICAgIG1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgbWFya2VkSW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgbWFya2VkLmRlZmF1bHRzID0gbWFya2VkSW5zdGFuY2UuZGVmYXVsdHM7XG4gICAgICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgICAgIHJldHVybiBtYXJrZWQ7XG4gICAgfTtcbi8qKlxuICogR2V0cyB0aGUgb3JpZ2luYWwgbWFya2VkIGRlZmF1bHQgb3B0aW9ucy5cbiAqL1xubWFya2VkLmdldERlZmF1bHRzID0gX2dldERlZmF1bHRzO1xubWFya2VkLmRlZmF1bHRzID0gX2RlZmF1bHRzO1xuLyoqXG4gKiBVc2UgRXh0ZW5zaW9uXG4gKi9cbm1hcmtlZC51c2UgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgIG1hcmtlZEluc3RhbmNlLnVzZSguLi5hcmdzKTtcbiAgICBtYXJrZWQuZGVmYXVsdHMgPSBtYXJrZWRJbnN0YW5jZS5kZWZhdWx0cztcbiAgICBjaGFuZ2VEZWZhdWx0cyhtYXJrZWQuZGVmYXVsdHMpO1xuICAgIHJldHVybiBtYXJrZWQ7XG59O1xuLyoqXG4gKiBSdW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IHRva2VuXG4gKi9cbm1hcmtlZC53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VucywgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbWFya2VkSW5zdGFuY2Uud2Fsa1Rva2Vucyh0b2tlbnMsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIENvbXBpbGVzIG1hcmtkb3duIHRvIEhUTUwgd2l0aG91dCBlbmNsb3NpbmcgYHBgIHRhZy5cbiAqXG4gKiBAcGFyYW0gc3JjIFN0cmluZyBvZiBtYXJrZG93biBzb3VyY2UgdG8gYmUgY29tcGlsZWRcbiAqIEBwYXJhbSBvcHRpb25zIEhhc2ggb2Ygb3B0aW9uc1xuICogQHJldHVybiBTdHJpbmcgb2YgY29tcGlsZWQgSFRNTFxuICovXG5tYXJrZWQucGFyc2VJbmxpbmUgPSBtYXJrZWRJbnN0YW5jZS5wYXJzZUlubGluZTtcbi8qKlxuICogRXhwb3NlXG4gKi9cbm1hcmtlZC5QYXJzZXIgPSBfUGFyc2VyO1xubWFya2VkLnBhcnNlciA9IF9QYXJzZXIucGFyc2U7XG5tYXJrZWQuUmVuZGVyZXIgPSBfUmVuZGVyZXI7XG5tYXJrZWQuVGV4dFJlbmRlcmVyID0gX1RleHRSZW5kZXJlcjtcbm1hcmtlZC5MZXhlciA9IF9MZXhlcjtcbm1hcmtlZC5sZXhlciA9IF9MZXhlci5sZXg7XG5tYXJrZWQuVG9rZW5pemVyID0gX1Rva2VuaXplcjtcbm1hcmtlZC5Ib29rcyA9IF9Ib29rcztcbm1hcmtlZC5wYXJzZSA9IG1hcmtlZDtcbmNvbnN0IG9wdGlvbnMgPSBtYXJrZWQub3B0aW9ucztcbmNvbnN0IHNldE9wdGlvbnMgPSBtYXJrZWQuc2V0T3B0aW9ucztcbmNvbnN0IHVzZSA9IG1hcmtlZC51c2U7XG5jb25zdCB3YWxrVG9rZW5zID0gbWFya2VkLndhbGtUb2tlbnM7XG5jb25zdCBwYXJzZUlubGluZSA9IG1hcmtlZC5wYXJzZUlubGluZTtcbmNvbnN0IHBhcnNlID0gbWFya2VkO1xuY29uc3QgcGFyc2VyID0gX1BhcnNlci5wYXJzZTtcbmNvbnN0IGxleGVyID0gX0xleGVyLmxleDtcblxuZXhwb3J0IHsgX0hvb2tzIGFzIEhvb2tzLCBfTGV4ZXIgYXMgTGV4ZXIsIE1hcmtlZCwgX1BhcnNlciBhcyBQYXJzZXIsIF9SZW5kZXJlciBhcyBSZW5kZXJlciwgX1RleHRSZW5kZXJlciBhcyBUZXh0UmVuZGVyZXIsIF9Ub2tlbml6ZXIgYXMgVG9rZW5pemVyLCBfZGVmYXVsdHMgYXMgZGVmYXVsdHMsIF9nZXREZWZhdWx0cyBhcyBnZXREZWZhdWx0cywgbGV4ZXIsIG1hcmtlZCwgb3B0aW9ucywgcGFyc2UsIHBhcnNlSW5saW5lLCBwYXJzZXIsIHNldE9wdGlvbnMsIHVzZSwgd2Fsa1Rva2VucyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFya2VkLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZ2V0RGVmYXVsdHMiLCJhc3luYyIsImJyZWFrcyIsImV4dGVuc2lvbnMiLCJnZm0iLCJob29rcyIsInBlZGFudGljIiwicmVuZGVyZXIiLCJzaWxlbnQiLCJ0b2tlbml6ZXIiLCJ3YWxrVG9rZW5zIiwiX2RlZmF1bHRzIiwiY2hhbmdlRGVmYXVsdHMiLCJuZXdEZWZhdWx0cyIsImVzY2FwZVRlc3QiLCJlc2NhcGVSZXBsYWNlIiwiUmVnRXhwIiwic291cmNlIiwiZXNjYXBlVGVzdE5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZU5vRW5jb2RlIiwiZXNjYXBlUmVwbGFjZW1lbnRzIiwiZ2V0RXNjYXBlUmVwbGFjZW1lbnQiLCJjaCIsImVzY2FwZSQxIiwiaHRtbCIsImVuY29kZSIsInRlc3QiLCJyZXBsYWNlIiwidW5lc2NhcGVUZXN0IiwidW5lc2NhcGUiLCJfIiwibiIsInRvTG93ZXJDYXNlIiwiY2hhckF0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJjYXJldCIsImVkaXQiLCJyZWdleCIsIm9wdCIsIm9iaiIsIm5hbWUiLCJ2YWwiLCJ2YWxTb3VyY2UiLCJnZXRSZWdleCIsImNsZWFuVXJsIiwiaHJlZiIsImVuY29kZVVSSSIsImUiLCJub29wVGVzdCIsImV4ZWMiLCJzcGxpdENlbGxzIiwidGFibGVSb3ciLCJjb3VudCIsInJvdyIsIm1hdGNoIiwib2Zmc2V0Iiwic3RyIiwiZXNjYXBlZCIsImN1cnIiLCJjZWxscyIsInNwbGl0IiwiaSIsInRyaW0iLCJzaGlmdCIsImxlbmd0aCIsInBvcCIsInNwbGljZSIsInB1c2giLCJydHJpbSIsImMiLCJpbnZlcnQiLCJsIiwic3VmZkxlbiIsImN1cnJDaGFyIiwic2xpY2UiLCJmaW5kQ2xvc2luZ0JyYWNrZXQiLCJiIiwiaW5kZXhPZiIsImxldmVsIiwib3V0cHV0TGluayIsImNhcCIsImxpbmsiLCJyYXciLCJsZXhlciIsInRpdGxlIiwidGV4dCIsInN0YXRlIiwiaW5MaW5rIiwidG9rZW4iLCJ0eXBlIiwidG9rZW5zIiwiaW5saW5lVG9rZW5zIiwiaW5kZW50Q29kZUNvbXBlbnNhdGlvbiIsIm1hdGNoSW5kZW50VG9Db2RlIiwiaW5kZW50VG9Db2RlIiwibWFwIiwibm9kZSIsIm1hdGNoSW5kZW50SW5Ob2RlIiwiaW5kZW50SW5Ob2RlIiwiam9pbiIsIl9Ub2tlbml6ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJzcGFjZSIsInNyYyIsInJ1bGVzIiwiYmxvY2siLCJuZXdsaW5lIiwiY29kZSIsImNvZGVCbG9ja1N0eWxlIiwiZmVuY2VzIiwibGFuZyIsImlubGluZSIsImFueVB1bmN0dWF0aW9uIiwiaGVhZGluZyIsInRyaW1tZWQiLCJkZXB0aCIsImhyIiwiYmxvY2txdW90ZSIsInRvcCIsImJsb2NrVG9rZW5zIiwibGlzdCIsImJ1bGwiLCJpc29yZGVyZWQiLCJvcmRlcmVkIiwic3RhcnQiLCJsb29zZSIsIml0ZW1zIiwiaXRlbVJlZ2V4IiwiaXRlbUNvbnRlbnRzIiwiZW5kc1dpdGhCbGFua0xpbmUiLCJlbmRFYXJseSIsImxpbmUiLCJ0IiwicmVwZWF0IiwibmV4dExpbmUiLCJpbmRlbnQiLCJ0cmltU3RhcnQiLCJzZWFyY2giLCJibGFua0xpbmUiLCJuZXh0QnVsbGV0UmVnZXgiLCJNYXRoIiwibWluIiwiaHJSZWdleCIsImZlbmNlc0JlZ2luUmVnZXgiLCJoZWFkaW5nQmVnaW5SZWdleCIsInJhd0xpbmUiLCJpc3Rhc2siLCJpc2NoZWNrZWQiLCJ0YXNrIiwiY2hlY2tlZCIsInRyaW1FbmQiLCJzcGFjZXJzIiwiZmlsdGVyIiwiaGFzTXVsdGlwbGVMaW5lQnJlYWtzIiwic29tZSIsInByZSIsImRlZiIsInRhZyIsInRhYmxlIiwiaGVhZGVycyIsImFsaWducyIsInJvd3MiLCJpdGVtIiwiaGVhZGVyIiwiYWxpZ24iLCJjZWxsIiwibGhlYWRpbmciLCJwYXJhZ3JhcGgiLCJlc2NhcGUiLCJpblJhd0Jsb2NrIiwidHJpbW1lZFVybCIsInJ0cmltU2xhc2giLCJsYXN0UGFyZW5JbmRleCIsImxpbmtMZW4iLCJyZWZsaW5rIiwibGlua3MiLCJub2xpbmsiLCJsaW5rU3RyaW5nIiwiZW1TdHJvbmciLCJtYXNrZWRTcmMiLCJwcmV2Q2hhciIsImVtU3Ryb25nTERlbGltIiwibmV4dENoYXIiLCJwdW5jdHVhdGlvbiIsImxMZW5ndGgiLCJyRGVsaW0iLCJyTGVuZ3RoIiwiZGVsaW1Ub3RhbCIsIm1pZERlbGltVG90YWwiLCJlbmRSZWciLCJlbVN0cm9uZ1JEZWxpbUFzdCIsImVtU3Ryb25nUkRlbGltVW5kIiwibGFzdEluZGV4IiwibGFzdENoYXJMZW5ndGgiLCJpbmRleCIsImNvZGVzcGFuIiwiaGFzTm9uU3BhY2VDaGFycyIsImhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzIiwiYnIiLCJkZWwiLCJhdXRvbGluayIsInVybCIsInByZXZDYXBaZXJvIiwiX2JhY2twZWRhbCIsImlubGluZVRleHQiLCJibG9ja0NvZGUiLCJidWxsZXQiLCJfcGFyYWdyYXBoIiwiYmxvY2tUZXh0IiwiX2Jsb2NrTGFiZWwiLCJfdGFnIiwiX2NvbW1lbnQiLCJibG9ja05vcm1hbCIsImdmbVRhYmxlIiwiYmxvY2tHZm0iLCJibG9ja1BlZGFudGljIiwiaW5saW5lQ29kZSIsIl9wdW5jdHVhdGlvbiIsImJsb2NrU2tpcCIsIl9pbmxpbmVDb21tZW50IiwiX2lubGluZUxhYmVsIiwicmVmbGlua1NlYXJjaCIsImlubGluZU5vcm1hbCIsImlubGluZVBlZGFudGljIiwiaW5saW5lR2ZtIiwiaW5saW5lQnJlYWtzIiwibm9ybWFsIiwiX0xleGVyIiwiT2JqZWN0IiwiY3JlYXRlIiwiaW5saW5lUXVldWUiLCJsZXgiLCJsZXhJbmxpbmUiLCJuZXh0IiwibGVhZGluZyIsInRhYnMiLCJsYXN0VG9rZW4iLCJjdXRTcmMiLCJsYXN0UGFyYWdyYXBoQ2xpcHBlZCIsImV4dFRva2VuaXplciIsImNhbGwiLCJzdGFydEJsb2NrIiwic3RhcnRJbmRleCIsIkluZmluaXR5IiwidGVtcFNyYyIsInRlbXBTdGFydCIsImZvckVhY2giLCJnZXRTdGFydEluZGV4IiwiZXJyTXNnIiwiY2hhckNvZGVBdCIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwia2VlcFByZXZDaGFyIiwia2V5cyIsImluY2x1ZGVzIiwibGFzdEluZGV4T2YiLCJzdGFydElubGluZSIsIl9SZW5kZXJlciIsImluZm9zdHJpbmciLCJxdW90ZSIsImJvZHkiLCJzdGFydGF0dCIsImxpc3RpdGVtIiwiY2hlY2tib3giLCJ0YWJsZXJvdyIsImNvbnRlbnQiLCJ0YWJsZWNlbGwiLCJmbGFncyIsInN0cm9uZyIsImVtIiwiY2xlYW5IcmVmIiwib3V0IiwiaW1hZ2UiLCJfVGV4dFJlbmRlcmVyIiwiX1BhcnNlciIsInRleHRSZW5kZXJlciIsInBhcnNlIiwicGFyc2VyIiwicGFyc2VJbmxpbmUiLCJyZW5kZXJlcnMiLCJnZW5lcmljVG9rZW4iLCJyZXQiLCJoZWFkaW5nVG9rZW4iLCJjb2RlVG9rZW4iLCJ0YWJsZVRva2VuIiwiaiIsImsiLCJibG9ja3F1b3RlVG9rZW4iLCJsaXN0VG9rZW4iLCJpdGVtQm9keSIsInVuc2hpZnQiLCJodG1sVG9rZW4iLCJwYXJhZ3JhcGhUb2tlbiIsInRleHRUb2tlbiIsImVzY2FwZVRva2VuIiwidGFnVG9rZW4iLCJsaW5rVG9rZW4iLCJpbWFnZVRva2VuIiwic3Ryb25nVG9rZW4iLCJlbVRva2VuIiwiY29kZXNwYW5Ub2tlbiIsImRlbFRva2VuIiwiX0hvb2tzIiwicGFzc1Rocm91Z2hIb29rcyIsIlNldCIsInByZXByb2Nlc3MiLCJtYXJrZG93biIsInBvc3Rwcm9jZXNzIiwicHJvY2Vzc0FsbFRva2VucyIsIk1hcmtlZCIsImFyZ3MiLCJkZWZhdWx0cyIsInNldE9wdGlvbnMiLCJwYXJzZU1hcmtkb3duIiwiUGFyc2VyIiwiUmVuZGVyZXIiLCJUZXh0UmVuZGVyZXIiLCJMZXhlciIsIlRva2VuaXplciIsIkhvb2tzIiwidXNlIiwiY2FsbGJhY2siLCJ2YWx1ZXMiLCJjb25jYXQiLCJjaGlsZFRva2VucyIsImZsYXQiLCJwYWNrIiwib3B0cyIsImV4dCIsInByZXZSZW5kZXJlciIsImFwcGx5IiwiZXh0TGV2ZWwiLCJwcm9wIiwicmVuZGVyZXJQcm9wIiwicmVuZGVyZXJGdW5jIiwidG9rZW5pemVyUHJvcCIsInRva2VuaXplckZ1bmMiLCJwcmV2VG9rZW5pemVyIiwiaG9va3NQcm9wIiwiaG9va3NGdW5jIiwicHJldkhvb2siLCJoYXMiLCJhcmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJwYWNrV2Fsa3Rva2VucyIsIm9yaWdPcHQiLCJ3YXJuIiwidGhyb3dFcnJvciIsIm9uRXJyb3IiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImFsbCIsImNhdGNoIiwibWVzc2FnZSIsIm1zZyIsInJlamVjdCIsIm1hcmtlZEluc3RhbmNlIiwibWFya2VkIiwiZ2V0RGVmYXVsdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/marked/lib/marked.esm.js\n");

/***/ })

};
;